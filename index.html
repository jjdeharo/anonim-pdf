<!doctype html>
<!--
  Anonimizador de PDF — Copyright (C) 2025 Juan José de Haro
  Licencia del código: GNU Affero General Public License v3.0 (AGPL-3.0)
-->
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="icon" type="image/svg+xml" href="./favicon.svg" />
  <title>Anonimizador de PDF — cliente</title>
  <style>
    :root { color-scheme: light dark; }
    * { box-sizing: border-box; }
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Arial, "Apple Color Emoji", "Segoe UI Emoji"; margin: 0; }
    header { position: sticky; top: 0; padding: .75rem 1rem; border-bottom: 1px solid #8883; backdrop-filter: blur(6px); }
    main { display: grid; grid-template-columns: 360px 1fr; gap: 1rem; padding: 1rem; transition: grid-template-columns .35s ease; }
    @media (max-width: 900px){ main { grid-template-columns: 1fr; } }
    .panel { border: 1px solid #8884; border-radius: .75rem; padding: .75rem; }
    .row { display: flex; gap: .5rem; flex-wrap: wrap; align-items: center; }
    button, input[type="number"], input[type="file"], select { padding: .5rem .6rem; border-radius: .5rem; border: 1px solid #8884; background: inherit; }
    button { cursor: pointer; }
    .panelToggle { width: 2.4rem; height: 2.4rem; border-radius: 50%; display: inline-flex; align-items: center; justify-content: center; padding: 0; border: 1px solid color-mix(in srgb, #16a34a 35%, transparent 65%); background: color-mix(in srgb, canvas 93%, #16a34a 7%); color: color-mix(in srgb, canvastext 88%, #0f2716 12%); box-shadow: 0 1px 4px #0002; transition: background .2s ease, color .2s ease, transform .2s ease; flex: 0 0 2.4rem; position: relative; }
    .panelToggle svg { width: 1.35rem; height: 1.35rem; }
    #toggleControls .icon-show { display: none; }
    body.controlsHidden #toggleControls .icon-hide { display: none; }
    body.controlsHidden #toggleControls .icon-show { display: block; }
    .panelToggle:hover { background: color-mix(in srgb, canvas 88%, #16a34a 12%); }
    .panelToggle:focus-visible { outline: 2px solid #16a34a; outline-offset: 2px; }
    #export,
    #btnClearRects { background: color-mix(in srgb, canvas 85%, #16a34a 15%); border-color: color-mix(in srgb, #16a34a 35%, transparent 65%); color: color-mix(in srgb, canvastext 88%, #0f2716 12%); }
    #export { font-weight: 600; }
    #export:disabled,
    #btnClearRects:disabled { opacity: .6; }
    .fileDrop { flex: 1 1 200px; display: flex; align-items: center; justify-content: center; gap: .5rem; border: 1px dashed color-mix(in srgb, canvastext 40%, transparent 60%); border-radius: .65rem; padding: .6rem .75rem; min-height: 3.25rem; background: color-mix(in srgb, canvas 94%, #16a34a 6%); cursor: pointer; transition: border-color .2s ease, background .2s ease, color .2s ease; text-align: center; }
    .fileDrop:hover { border-color: color-mix(in srgb, #16a34a 55%, transparent 45%); background: color-mix(in srgb, canvas 90%, #16a34a 10%); }
    .fileDrop.dragging { border-color: color-mix(in srgb, #16a34a 70%, transparent 30%); background: color-mix(in srgb, canvas 85%, #16a34a 15%); color: color-mix(in srgb, canvastext 92%, #0f2716 8%); }
    .fileDropInput { display: none; }
    .muted { opacity: .8; font-size: .92rem; }
    .kbd { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace; background: #8882; border: 1px solid #8884; padding: 0 .35rem; border-radius: .35rem; }
    fieldset { border: none; margin: 0; padding: 0; }
    .namingField { display: flex; gap: .75rem; flex-wrap: wrap; align-items: center; }
    .namingField legend { font-size: .92rem; font-weight: 600; margin-right: .25rem; }
    .namingField label { display: inline-flex; align-items: center; gap: .35rem; }
    .rectSettings { border: 1px solid #8885; border-radius: .65rem; padding: .6rem .75rem; margin-bottom: .75rem; }
    .rectSettings legend { font-size: .92rem; font-weight: 600; padding: 0 .35rem; }
    .rectSettings .rectControls { display: flex; gap: .75rem; flex-wrap: wrap; align-items: flex-start; }
    .rectSettings .rectStack { display: flex; flex-direction: column; gap: .4rem; min-width: 11rem; }
    .panelControls { position: relative; transition: transform .35s ease, opacity .25s ease; }
    .panelTopRow { align-items: stretch; }
    .panelTopRow .fileDrop { flex: 1 1 auto; }
    .rectSettings .applyAll { display: flex; align-items: center; gap: .4rem; }
    #viewerContainer { position: relative; overflow-y: auto; max-height: 75vh; padding: 1rem .5rem .5rem; }
    #pagesContainer { display: flex; flex-direction: column; gap: 1.5rem; align-items: center; }
    .viewerToolbar { position: sticky; top: .75rem; z-index: 6; display: flex; align-items: center; justify-content: center; gap: .75rem; padding: 0 1.5rem; margin-bottom: .25rem; }
    #showControls { position: absolute; left: 1.25rem; top: 50%; transform: translate(-50%, -50%); opacity: 0; visibility: hidden; pointer-events: none; transition: opacity .2s ease; }
    #zoomOverlay { display: inline-flex; align-items: center; gap: .5rem; padding: .35rem .6rem; border-radius: .6rem; border: 1px solid #8886; box-shadow: 0 6px 16px #0005; background: color-mix(in srgb, canvas 65%, #222 35%); backdrop-filter: blur(6px); }
    #zoomOverlay button { background: color-mix(in srgb, canvas 55%, #000 45%); color: inherit; border-radius: .5rem; border: 1px solid #8886; min-width: 2.1rem; }
    body.controlsHidden main { grid-template-columns: 0px 1fr; }
    body.controlsHidden .panelControls { transform: translateX(-2rem); opacity: 0; pointer-events: none; }
    body.controlsHidden #showControls { opacity: 1; visibility: visible; pointer-events: auto; }
    @media (prefers-color-scheme: light) {
      #zoomOverlay { background: color-mix(in srgb, canvas 95%, #666 5%); border-color: color-mix(in srgb, #000 18%, transparent 82%); box-shadow: 0 6px 18px #0002; }
      #zoomOverlay button { background: color-mix(in srgb, canvas 98%, #666 2%); border-color: color-mix(in srgb, #000 25%, transparent 75%); color: color-mix(in srgb, canvastext 92%, #000 8%); }
      #zoomOverlay button:disabled { opacity: .55; }
    }
    #zoomOverlay button:disabled { opacity: .45; }
    .pageView { position: relative; }
    .pageView img { display: block; border: 1px solid #8884; border-radius: .5rem; background: #fff; user-select: none; }
    .pageView .pdfPageCanvas { display: none; }
    .pageView .pdfOverlay { position: absolute; inset: 0; pointer-events: auto; border-radius: .5rem; cursor: crosshair; z-index: 2; display: block; }
    .pageView.active { outline: 2px solid #16a34a; outline-offset: 6px; }
    .badget { font-size: .85rem; opacity: .8; }
    footer { padding: .75rem 1rem; border-top: 1px solid #8883; }
    #profModal { position: fixed; inset: 0; display: flex; align-items: center; justify-content: center; background: color-mix(in srgb, #000 55%, transparent 45%); backdrop-filter: blur(4px); padding: 1.5rem; z-index: 999; opacity: 0; pointer-events: none; transition: opacity .25s ease; }
    #profModal.active { opacity: 1; pointer-events: auto; }
    #profModal .modalDialog { max-width: 640px; width: min(100%, 640px); background: color-mix(in srgb, canvas 92%, #16a34a 8%); color: inherit; border: 1px solid color-mix(in srgb, #16a34a 35%, transparent 65%); border-radius: .9rem; box-shadow: 0 14px 32px #0006; padding: 1.2rem 1.4rem 1.5rem; display: flex; flex-direction: column; gap: .85rem; position: relative; }
    #profModal h2 { margin: 0; font-size: 1.2rem; }
    #profModal p { margin: 0; line-height: 1.55; }
    #profModal button.modalClose { align-self: flex-end; border: none; background: none; color: inherit; font-size: .95rem; cursor: pointer; padding: .35rem .6rem; border-radius: .5rem; transition: background .2s ease; }
    #profModal button.modalClose:hover { background: color-mix(in srgb, canvas 85%, #16a34a 15%); }
    .infoLink { color: inherit; text-decoration: underline; font-size: .9rem; cursor: pointer; border: none; background: none; padding: 0; }
    .panelInfoLink { margin-left: .35rem; align-self: center; }
  </style>
  <!-- Bibliotecas locales para funcionar sin conexión -->
  <script src="./vendor/pdfjs/pdf.v216.min.js" defer></script>
  <script src="./vendor/jspdf/jspdf.umd.min.js" defer></script>
  <script src="./vendor/jszip/jszip.min.js" defer></script>
</head>
<body>
  <header class="row">
    <img src="./favicon.svg" alt="" width="32" height="32" aria-hidden="true" />
    <strong>Anonimizador de PDF</strong>
  </header>

  <main>
    <section class="panel panelControls">
      <div class="row panelTopRow" style="margin-bottom:.5rem">
        <button id="toggleControls" class="panelToggle panelToggle-collapse" type="button" aria-pressed="false" title="Ocultar panel de controles">
          <svg class="icon-hide" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
            <rect x="3" y="3" width="6" height="18" rx="2" />
            <path d="M14 8l-4 4 4 4" />
          </svg>
          <svg class="icon-show" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
            <rect x="3" y="3" width="2" height="18" rx="1" />
            <path d="M10 8l4 4-4 4" />
          </svg>
        </button>
        <button id="openProfModal" class="infoLink panelInfoLink" type="button">Aviso importante</button>
        <div id="fileDrop" class="fileDrop">
          <input id="file" class="fileDropInput" type="file" accept="application/pdf,image/*" />
          <span>Arrastra un PDF o imagen o haz clic para abrirlo</span>
        </div>
      </div>
      <div class="row" style="margin-bottom:.5rem; justify-content:flex-start">
        <div><span>Página </span><span id="pageNum">-</span><span> / </span><span id="pageCount">-</span></div>
      </div>
      <fieldset class="rectSettings" style="margin-bottom:.75rem">
        <legend>Uso</legend>
        <p class="muted" style="margin:0">Arrastra con el ratón para definir rectángulos sobre el nombre. Doble clic borra el último rectángulo. En PDF, dibuja con el botón derecho para aplicar el rectángulo a todas las páginas.</p>
      </fieldset>
      <fieldset class="rectSettings">
        <legend>Dibujo del rectángulo</legend>
        <div class="rectControls">
          <label>Grosor del borde: <input id="strokeW" type="number" min="1" max="8" value="2" style="width:4.5rem" /></label>
          <div class="rectStack">
            <label>Opacidad tapa: <input id="opacity" type="number" min="0.1" max="1" step="0.1" value="1" style="width:4.5rem" /></label>
            <label class="muted applyAll">
              <input id="applyAllPages" type="checkbox" />
              Aplicar el rectángulo a todas las páginas
            </label>
          </div>
          <select id="maskColor" title="Color de la máscara">
            <option value="#000000" selected>Negro</option>
            <option value="#ffffff">Blanco</option>
            <option value="#888888">Gris</option>
          </select>
        </div>
      </fieldset>
      <button id="btnClearRects" disabled style="margin-bottom:.75rem">Limpiar rectángulos de esta página</button>
      <fieldset class="namingField" style="margin-bottom:.75rem">
        <legend>Nombre del archivo exportado</legend>
        <label><input type="radio" name="namingOption" value="derived" checked>Mismo nombre + _anonim</label>
        <label><input type="radio" name="namingOption" value="fixed">anonim.pdf</label>
      </fieldset>
      <div class="row" style="margin-bottom:.5rem">
        <button id="export" disabled>Exportar anonimizado</button>
        <select id="exportMode" aria-label="Formato de exportación" disabled style="min-width:12rem">
          <option value="pdf">PDF anonimizado</option>
          <option value="zip">ZIP con una página por PNG</option>
          <option value="png">Imagen PNG anonimizada</option>
        </select>
        <a id="dlLink" download style="display:none"></a>
      </div>
      <p id="exportNotice" class="muted" style="display:none; margin-top:-.25rem; margin-bottom:.75rem;"></p>
      <details>
        <summary>Notas sobre seguridad del anonimizado</summary>
        <ul>
          <li>La exportación genera un PDF de imágenes (rasterizado). El texto original desaparece: ya no es seleccionable ni extraíble como texto.</li>
          <li>Esto es adecuado para ocultar nombres propios de trabajos entregados, con la contrapartida de mayor tamaño y pérdida de accesibilidad.</li>
          <li>Uso totalmente local en tu navegador.</li>
        </ul>
      </details>

      <details>
        <summary>Créditos y soporte</summary>
        <p class="muted">¿Dudas o sugerencias? Pulsa el botón verde <a href="https://github.com/jjdeharo/anonim-pdf/issues" style="color:inherit; text-decoration:underline;">New issue</a> en GitHub.</p>
        <p class="muted">Anonimizador de PDF · © 2025 <a href="https://bilateria.es" style="color:inherit; text-decoration:underline;">Juan José de Haro</a> · Recurso: <a href="https://github.com/jjdeharo/anonim-pdf" style="color:inherit; text-decoration:underline;">github.com/jjdeharo/anonim-pdf</a></p>
        <p class="muted"><a href="./LICENSE.txt" style="color:inherit; text-decoration:underline;">Licencia del código: AGPL v3</a></p>
      </details>

    </section>

    <section class="panel panelViewer">
      <div class="viewerToolbar">
        <button id="showControls" class="panelToggle panelToggle-show" type="button" aria-pressed="false" title="Mostrar panel de controles">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
            <rect x="3" y="3" width="2" height="18" rx="1" />
            <path d="M10 8l4 4-4 4" />
          </svg>
        </button>
        <div id="zoomOverlay">
          <span>Zoom:</span>
          <button id="zoomOut" type="button" disabled>-</button>
          <span id="zoomDisplay">100%</span>
          <button id="zoomIn" type="button" disabled>+</button>
          <button id="zoomFit" type="button" disabled>Ajustar ancho</button>
        </div>
      </div>
      <div id="viewerContainer">
        <div id="pagesContainer"></div>
      </div>
    </section>
  </main>

  <div id="profModal" role="dialog" aria-modal="true" aria-labelledby="profModalTitle" aria-describedby="profModalBody">
    <div class="modalDialog">
      <button id="closeProfModal" class="modalClose" type="button">Cerrar aviso</button>
      <h2 id="profModalTitle">Aviso importante</h2>
      <div id="profModalBody" style="display:flex; flex-direction:column; gap:1rem;">
        <p><strong>Esta aplicación únicamente genera un PDF anonimizado</strong>, ocultando los datos identificativos del alumnado para que los documentos puedan emplearse en herramientas de inteligencia artificial sin exponer información personal.</p>
        <p>La inteligencia artificial puede servir de apoyo para obtener análisis parciales, detectar patrones o aportar nuevas perspectivas sobre los trabajos del alumnado. <strong>No debe confundirse su uso con la función docente</strong>: la IA no evalúa, no corrige y no puede asumir la responsabilidad educativa.</p>
        <p><strong>La evaluación, el juicio pedagógico y la calificación del alumnado corresponden siempre al profesorado.</strong> La IA puede complementar la reflexión, pero nunca sustituir el criterio profesional ni la decisión final del docente.</p>
      </div>
    </div>
  </div>

  <footer class="muted"></footer>

<script>
  window.addEventListener('DOMContentLoaded', () => {
    const havePdfjs = typeof window.pdfjsLib !== 'undefined';
    if (!havePdfjs) {
      alert('No se pudo cargar pdf.js. Comprueba la conexión o políticas de bloqueadores. He cambiado al build legacy para exponer "pdfjsLib".');
      return;
    }

    const WORKER_SRC = './vendor/pdfjs/pdf.worker.v216.min.js';
    try {
      pdfjsLib.GlobalWorkerOptions.workerSrc = WORKER_SRC;
    } catch (err) {
      console.warn('Fallo al configurar worker pdf.js, usando modo sin worker.', err);
      pdfjsLib.disableWorker = true;
    }

    const viewerContainer = document.getElementById('viewerContainer');
    const pagesContainer = document.getElementById('pagesContainer');
    const fileDrop = document.getElementById('fileDrop');
    const fileDropText = fileDrop.querySelector('span');
    const fileInput = document.getElementById('file');
    const pageNumEl = document.getElementById('pageNum');
    const pageCountEl = document.getElementById('pageCount');
    const btnExport = document.getElementById('export');
    const btnClearRects = document.getElementById('btnClearRects');
    const exportModeEl = document.getElementById('exportMode');
    const exportNoticeEl = document.getElementById('exportNotice');
    const downloadLink = document.getElementById('dlLink');
    const opacityEl = document.getElementById('opacity');
    const strokeWEl = document.getElementById('strokeW');
    const maskColorEl = document.getElementById('maskColor');
    const namingRadios = document.querySelectorAll('input[name="namingOption"]');
    const applyAllEl = document.getElementById('applyAllPages');
    const zoomOutBtn = document.getElementById('zoomOut');
    const zoomInBtn = document.getElementById('zoomIn');
    const zoomFitBtn = document.getElementById('zoomFit');
    const zoomDisplay = document.getElementById('zoomDisplay');
    const toggleControlsBtn = document.getElementById('toggleControls');
    const showControlsBtn = document.getElementById('showControls');
    const profModal = document.getElementById('profModal');
    const closeProfModalBtn = document.getElementById('closeProfModal');
    const openProfModalBtn = document.getElementById('openProfModal');
    let lastFocusBeforeModal = null;

    let pdfDoc = null;
    let imageDoc = null;
    let docType = null;
    let scale = 1;
    let rectsByPage = {};
    let currentFileName = 'documento.pdf';
    let namingStrategy = 'derived';
    let fitScale = 1;
    let basePageWidth = 0;
    let zoomFactor = 1;
    let resizeTimeout = null;
    const MIN_ZOOM = 0.6;
    const MAX_ZOOM = 3;
    const ZOOM_STEP = 0.2;
    const EXPORT_RENDER_SCALE = 2;
    const EXPORT_IMAGE_QUALITY = 0.92;
    const ZOOM_KEY = 'anonim-pdf-zoom';
    const CONTROLS_HIDDEN_KEY = 'anonim-pdf-controls-hidden';
    const EXPORT_MODE_KEY = 'anonim-pdf-export-mode';
    const SUPPORTED_IMAGE_REGEX = /\.(png|jpe?g|gif|bmp|webp|tiff?)$/i;
    const SINGLE_IMAGE_TARGET_WIDTH = 2048;
    const SINGLE_IMAGE_MAX_HEIGHT = 16384;
    const SINGLE_IMAGE_MAX_SCALE = 4.5;
    const SINGLE_IMAGE_MIN_SCALE = 1.6;
    const SINGLE_IMAGE_PAGE_GAP = 24;
    const SINGLE_IMAGE_CANVAS_LIMIT = 32760;
    const SINGLE_IMAGE_BACKGROUND = '#ffffff';
    let activePage = 1;
    let pageCount = 0;
    const pageViews = new Map();
    const pageStates = new Map();

    const observer = 'IntersectionObserver' in window
      ? new IntersectionObserver((entries) => {
          let nextPage = activePage;
          let maxRatio = 0;
          for (const entry of entries) {
            if (entry.isIntersecting && entry.intersectionRatio > maxRatio) {
              nextPage = Number(entry.target.dataset.page);
              maxRatio = entry.intersectionRatio;
            }
          }
          if (nextPage !== activePage && pageViews.has(nextPage)) {
            setActivePage(nextPage);
          }
        }, { root: viewerContainer, threshold: [0.2, 0.45, 0.7] })
      : null;

    const DEFAULT_DROP_TEXT = 'Arrastra un PDF o imagen o haz clic para abrirlo';
    fileDropText.textContent = DEFAULT_DROP_TEXT;
    resetExportControls();

    const storedControlsHidden = localStorage.getItem(CONTROLS_HIDDEN_KEY) === 'true';
    setControlsHidden(storedControlsHidden);

    function persistControlsHidden(hidden) {
      localStorage.setItem(CONTROLS_HIDDEN_KEY, hidden ? 'true' : 'false');
    }

    toggleControlsBtn?.addEventListener('click', () => {
      const nextHidden = !document.body.classList.contains('controlsHidden');
      setControlsHidden(nextHidden);
      persistControlsHidden(nextHidden);
    });

    showControlsBtn?.addEventListener('click', () => {
      setControlsHidden(false);
      persistControlsHidden(false);
      toggleControlsBtn?.focus({ preventScroll: true });
    });

    openProfModalBtn?.addEventListener('click', () => openProfModal());
    closeProfModalBtn?.addEventListener('click', () => closeProfModal());
    profModal?.addEventListener('click', (event) => {
      if (event.target === profModal) {
        closeProfModal();
      }
    });
    document.addEventListener('keydown', (event) => {
      if (event.key === 'Escape' && profModal?.classList.contains('active')) {
        closeProfModal();
      }
    });

    fileDrop.addEventListener('click', () => fileInput.click());
    fileDrop.addEventListener('dragenter', (e) => {
      e.preventDefault();
      fileDrop.classList.add('dragging');
    });
    fileDrop.addEventListener('dragover', (e) => {
      e.preventDefault();
      e.dataTransfer.dropEffect = 'copy';
      fileDrop.classList.add('dragging');
    });
    fileDrop.addEventListener('dragleave', (e) => {
      const next = e.relatedTarget;
      if (!next || !fileDrop.contains(next)) {
        fileDrop.classList.remove('dragging');
      }
    });
    fileDrop.addEventListener('drop', async (e) => {
      e.preventDefault();
      fileDrop.classList.remove('dragging');
      const files = e.dataTransfer?.files;
      if (!files || !files.length) return;
      const file = files[0];
      if (!await openDocument(file)) return;
      try {
        const dt = new DataTransfer();
        dt.items.add(file);
        fileInput.files = dt.files;
      } catch (err) {
        console.warn('No se pudo sincronizar input de archivo con el drop.', err);
      }
    });

    fileInput.addEventListener('change', async (e) => {
      const file = e.target.files[0];
      if (!file) return;
      await openDocument(file);
      e.target.value = '';
    });

    exportModeEl.addEventListener('change', () => {
      updateExportButtonLabel();
      if (docType === 'pdf') {
        localStorage.setItem(EXPORT_MODE_KEY, exportModeEl.value);
      }
      updateExportNotice();
    });

    btnClearRects.addEventListener('click', () => {
      if (!docType) return;
      rectsByPage[activePage] = [];
      drawOverlay(activePage);
      updateClearButtonState();
    });

    maskColorEl.addEventListener('change', redrawAllOverlays);
    opacityEl.addEventListener('change', redrawAllOverlays);
    strokeWEl.addEventListener('change', redrawAllOverlays);

    const NAMING_KEY = 'anonim-pdf-naming';
    const storedNaming = (localStorage.getItem(NAMING_KEY) || '').toLowerCase();
    if (storedNaming === 'fixed' || storedNaming === 'derived') {
      namingStrategy = storedNaming;
    }
    namingRadios.forEach((radio) => {
      radio.checked = radio.value === namingStrategy;
      radio.addEventListener('change', () => {
        if (radio.checked) {
          namingStrategy = radio.value === 'fixed' ? 'fixed' : 'derived';
          localStorage.setItem(NAMING_KEY, namingStrategy);
        }
      });
    });

    const storedZoom = parseFloat(localStorage.getItem(ZOOM_KEY) || '');
    if (!Number.isNaN(storedZoom)) {
      zoomFactor = clamp(storedZoom, MIN_ZOOM, MAX_ZOOM);
    }
    setZoomControlsEnabled(false);
    updateZoomDisplay();

    applyAllEl.checked = false;
    toggleApplyAllState();

    zoomInBtn.addEventListener('click', () => {
      setZoomFactor(zoomFactor + ZOOM_STEP).catch((err) => console.error(err));
    });
    zoomOutBtn.addEventListener('click', () => {
      setZoomFactor(zoomFactor - ZOOM_STEP).catch((err) => console.error(err));
    });
    zoomFitBtn.addEventListener('click', () => {
      setZoomFactor(1).catch((err) => console.error(err));
    });

    btnExport.addEventListener('click', async () => {
      if (btnExport.disabled || !docType) return;
      try {
        if (docType === 'pdf') {
          const mode = exportModeEl.value;
          if (mode === 'zip') {
            await exportPdfAsZip();
          } else if (mode === 'png-single') {
            await exportPdfAsSingleImage();
          } else {
            await exportPdfAsPdf();
          }
        } else if (docType === 'image') {
          await exportImageAsPng();
        }
      } catch (err) {
        console.error('Error durante la exportación.', err);
        alert('Ocurrió un error exportando el documento anonimizado.');
      }
    });

    function getMaskSettings() {
      const mask = maskColorEl.value || '#000';
      const alpha = Math.max(0.1, Math.min(1, Number(opacityEl.value) || 1));
      return { mask, alpha };
    }

    function getRectScaleForExport(targetScale) {
      return scale > 0 ? targetScale / scale : targetScale;
    }

    async function exportPdfAsPdf() {
      if (!pdfDoc) return;
      const jspdfNs = window.jspdf;
      if (!jspdfNs || typeof jspdfNs.jsPDF !== 'function') {
        alert('No se pudo cargar la librería jsPDF.');
        return;
      }
      const { jsPDF } = jspdfNs;
      const pdfOut = new jsPDF({ unit: 'pt', compress: true });
      pdfOut.deletePage(1);

      const { mask, alpha } = getMaskSettings();
      const totalPages = pdfDoc.numPages;
      for (let p = 1; p <= totalPages; p++) {
        const page = await pdfDoc.getPage(p);
        const baseViewport = page.getViewport({ scale: 1 });
        const exportViewport = page.getViewport({ scale: EXPORT_RENDER_SCALE });

        const pageCanvas = document.createElement('canvas');
        pageCanvas.width = exportViewport.width;
        pageCanvas.height = exportViewport.height;
        const pctx = pageCanvas.getContext('2d');
        await page.render({ canvasContext: pctx, viewport: exportViewport }).promise;

        const rects = rectsByPage[p] || [];
        const rectScale = getRectScaleForExport(EXPORT_RENDER_SCALE);
        paintMaskRects(pctx, rects, mask, alpha, rectScale);

        pdfOut.addPage([baseViewport.width, baseViewport.height]);
        pdfOut.setPage(pdfOut.getNumberOfPages());

        const img = pageCanvas.toDataURL('image/jpeg', EXPORT_IMAGE_QUALITY);
        pdfOut.addImage(img, 'JPEG', 0, 0, baseViewport.width, baseViewport.height, undefined, 'FAST');
      }

      const blob = pdfOut.output('blob');
      triggerDownload(blob, buildAnonName(currentFileName, '.pdf'));
    }

    async function exportPdfAsZip() {
      if (!pdfDoc) return;
      const JSZipCtor = window.JSZip;
      if (typeof JSZipCtor !== 'function') {
        alert('No se pudo cargar la librería JSZip.');
        return;
      }
      const zip = new JSZipCtor();
      const { mask, alpha } = getMaskSettings();
      const totalPages = pdfDoc.numPages;
      const padding = String(totalPages).length;

      for (let p = 1; p <= totalPages; p++) {
        const page = await pdfDoc.getPage(p);
        const exportViewport = page.getViewport({ scale: EXPORT_RENDER_SCALE });
        const pageCanvas = document.createElement('canvas');
        pageCanvas.width = exportViewport.width;
        pageCanvas.height = exportViewport.height;
        const ctx = pageCanvas.getContext('2d');
        await page.render({ canvasContext: ctx, viewport: exportViewport }).promise;

        const rects = rectsByPage[p] || [];
        const rectScale = getRectScaleForExport(EXPORT_RENDER_SCALE);
        paintMaskRects(ctx, rects, mask, alpha, rectScale);

        const dataUrl = pageCanvas.toDataURL('image/png');
        const base64 = dataUrl.split(',')[1] || '';
        const fileName = `pagina-${String(p).padStart(padding, '0')}.png`;
        zip.file(fileName, base64, { base64: true });
      }

      const blob = await zip.generateAsync({ type: 'blob' });
      triggerDownload(blob, buildAnonName(currentFileName, '.zip'));
    }

    async function exportPdfAsSingleImage() {
      if (!pdfDoc) return;
      const totalPages = pdfDoc.numPages;
      if (totalPages === 0) return;
      const { mask, alpha } = getMaskSettings();

      const entries = [];
      let maxWidth = 0;
      let totalHeight = 0;
      for (let p = 1; p <= totalPages; p++) {
        const page = await pdfDoc.getPage(p);
        const viewport = page.getViewport({ scale: 1 });
        entries.push({ pageNumber: p, page, width: viewport.width, height: viewport.height });
        maxWidth = Math.max(maxWidth, viewport.width);
        totalHeight += viewport.height;
      }

      const gapTotal = SINGLE_IMAGE_PAGE_GAP * Math.max(0, totalPages - 1);
      const heightScale = (SINGLE_IMAGE_MAX_HEIGHT - gapTotal) / totalHeight;
      const heightLimitScale = (SINGLE_IMAGE_CANVAS_LIMIT - gapTotal) / totalHeight;
      const widthScale = SINGLE_IMAGE_TARGET_WIDTH / maxWidth;
      const widthLimitScale = SINGLE_IMAGE_CANVAS_LIMIT / maxWidth;
      const scales = [widthScale, SINGLE_IMAGE_MAX_SCALE, heightScale, heightLimitScale, widthLimitScale]
        .filter((value) => Number.isFinite(value) && value > 0);
      let scaleFactor = scales.length ? Math.min(...scales) : 1;
      if (!Number.isFinite(scaleFactor) || scaleFactor <= 0) {
        scaleFactor = 1;
      }
      const requestedMin = SINGLE_IMAGE_MIN_SCALE;
      let minScaleNotice = false;
      if (scaleFactor < requestedMin) {
        minScaleNotice = true;
      }

      let exportHeight = Math.floor(totalHeight * scaleFactor) + gapTotal;
      if (exportHeight > SINGLE_IMAGE_CANVAS_LIMIT) {
        const adjustedScale = (SINGLE_IMAGE_CANVAS_LIMIT - gapTotal) / totalHeight;
        if (Number.isFinite(adjustedScale) && adjustedScale > 0) {
          scaleFactor = adjustedScale;
          exportHeight = Math.floor(totalHeight * scaleFactor) + gapTotal;
        } else {
          exportHeight = SINGLE_IMAGE_CANVAS_LIMIT;
        }
      }

      if (minScaleNotice) {
        alert('El PNG único se generará con menor resolución por la longitud del documento. Revisa que el resultado sea legible.');
      }

      const canvas = document.createElement('canvas');
      const exportWidth = Math.max(1, Math.floor(maxWidth * scaleFactor));
      canvas.width = Math.max(1, Math.min(exportWidth, SINGLE_IMAGE_CANVAS_LIMIT));
      canvas.height = Math.max(1, Math.min(exportHeight, SINGLE_IMAGE_CANVAS_LIMIT));
      const ctx = canvas.getContext('2d');
      ctx.fillStyle = SINGLE_IMAGE_BACKGROUND;
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      let offsetY = 0;
      const rectScale = getRectScaleForExport(scaleFactor);
      for (let i = 0; i < entries.length; i++) {
        const { page, pageNumber, width, height } = entries[i];
        const viewport = page.getViewport({ scale: scaleFactor });
        const renderCanvas = document.createElement('canvas');
        renderCanvas.width = Math.max(1, Math.round(viewport.width));
        renderCanvas.height = Math.max(1, Math.round(viewport.height));
        const rctx = renderCanvas.getContext('2d');
        await page.render({ canvasContext: rctx, viewport }).promise;

        const rects = rectsByPage[pageNumber] || [];
        paintMaskRects(rctx, rects, mask, alpha, rectScale);

        ctx.drawImage(renderCanvas, 0, offsetY);
        offsetY += renderCanvas.height;
        if (i < entries.length - 1) {
          offsetY += SINGLE_IMAGE_PAGE_GAP;
        }
        page.cleanup?.();
        entries[i].page = null;
      }

      const blob = await canvasToBlob(canvas, 'image/png');
      if (!blob) {
        alert('No se pudo generar la imagen única anonimizada.');
        return;
      }
      triggerDownload(blob, buildAnonName(currentFileName, '.png'));
    }

    async function exportImageAsPng() {
      if (!imageDoc) return;
      const { mask, alpha } = getMaskSettings();
      const canvas = document.createElement('canvas');
      canvas.width = imageDoc.width;
      canvas.height = imageDoc.height;
      const ctx = canvas.getContext('2d');
      ctx.drawImage(imageDoc.image, 0, 0, canvas.width, canvas.height);

      const rects = rectsByPage[1] || [];
      const rectScale = getRectScaleForExport(1);
      paintMaskRects(ctx, rects, mask, alpha, rectScale);

      const blob = await canvasToBlob(canvas, 'image/png');
      if (!blob) {
        alert('No se pudo generar la imagen anonimizada.');
        return;
      }
      triggerDownload(blob, buildAnonName(currentFileName, '.png'));
    }

    function canvasToBlob(canvas, type, quality) {
      return new Promise((resolve) => {
        canvas.toBlob(resolve, type, quality);
      });
    }

    function paintMaskRects(ctx, rects, color, alpha, rectScale) {
      if (!ctx || !Array.isArray(rects) || rects.length === 0) return;
      const factor = Number.isFinite(rectScale) && rectScale > 0 ? rectScale : 1;
      ctx.save();
      ctx.fillStyle = color;
      for (const rect of rects) {
        ctx.globalAlpha = alpha;
        ctx.fillRect(rect.x * factor, rect.y * factor, rect.w * factor, rect.h * factor);
      }
      ctx.restore();
    }

    function triggerDownload(blob, fileName) {
      if (!blob) return;
      const url = URL.createObjectURL(blob);
      downloadLink.href = url;
      downloadLink.download = fileName;
      downloadLink.click();
      downloadLink.style.display = 'none';
      setTimeout(() => URL.revokeObjectURL(url), 10_000);
    }

    function openProfModal() {
      if (!profModal) return;
      lastFocusBeforeModal = document.activeElement instanceof HTMLElement ? document.activeElement : null;
      profModal.classList.add('active');
      document.body.style.overflow = 'hidden';
      closeProfModalBtn?.focus({ preventScroll: true });
    }

    function closeProfModal() {
      if (!profModal) return;
      profModal.classList.remove('active');
      document.body.style.overflow = '';
      lastFocusBeforeModal?.focus?.({ preventScroll: true });
    }

    function setControlsHidden(hidden) {
      document.body.classList.toggle('controlsHidden', hidden);
      if (toggleControlsBtn) {
        toggleControlsBtn.setAttribute('aria-pressed', hidden ? 'true' : 'false');
        toggleControlsBtn.setAttribute('aria-label', hidden ? 'Mostrar panel de controles' : 'Ocultar panel de controles');
        toggleControlsBtn.setAttribute('title', hidden ? 'Mostrar panel de controles' : 'Ocultar panel de controles');
      }
      if (showControlsBtn) {
        showControlsBtn.setAttribute('aria-pressed', hidden ? 'true' : 'false');
        showControlsBtn.setAttribute('aria-label', 'Mostrar panel de controles');
        showControlsBtn.setAttribute('title', 'Mostrar panel de controles');
      }
    }

    function resetExportControls() {
      if (!exportModeEl) return;
      exportModeEl.innerHTML = '';
      exportModeEl.disabled = true;
      btnExport.disabled = true;
      btnExport.textContent = 'Exportar anonimizado';
      exportModeEl.value = '';
      exportModeEl.hidden = false;
      exportModeEl.dataset.singleLabel = '';
      clearExportNotice();
    }

    function configureExportForDoc(type) {
      if (!exportModeEl) return;
      exportModeEl.innerHTML = '';
      let defaultValue = '';
      let optionList = [];
      if (type === 'pdf') {
        optionList = [
          { value: 'pdf', label: 'PDF anonimizado' },
          { value: 'zip', label: 'ZIP con una página por PNG' }
        ];
        if (pageCount > 1) {
          optionList.push({ value: 'png-single', label: 'PNG con todas las páginas' });
        }
        for (const opt of optionList) {
          exportModeEl.appendChild(new Option(opt.label, opt.value));
        }
        const stored = localStorage.getItem(EXPORT_MODE_KEY);
        defaultValue = optionList.some((opt) => opt.value === stored) ? stored : 'pdf';
      } else {
        optionList = [{ value: 'png', label: 'Imagen PNG anonimizada' }];
        exportModeEl.appendChild(new Option(optionList[0].label, optionList[0].value));
        defaultValue = 'png';
      }
      const hasMultipleOptions = optionList.length > 1;
      exportModeEl.disabled = !hasMultipleOptions;
      exportModeEl.hidden = !hasMultipleOptions;
      btnExport.disabled = false;
      exportModeEl.value = defaultValue;
      exportModeEl.dataset.singleLabel = hasMultipleOptions ? '' : (optionList[0]?.label || '');
      updateExportButtonLabel();
      if (type !== 'pdf') {
        localStorage.removeItem(EXPORT_MODE_KEY);
      }
      updateExportNotice();
    }

    function updateExportButtonLabel() {
      let labelText = '';
      if (exportModeEl.hidden || exportModeEl.options.length === 1) {
        labelText = exportModeEl.dataset.singleLabel || exportModeEl.options[0]?.textContent || '';
      } else {
        const selected = exportModeEl.options[exportModeEl.selectedIndex];
        labelText = selected ? selected.textContent : '';
      }
      btnExport.textContent = labelText ? `Exportar ${labelText}` : 'Exportar anonimizado';
    }

    function updateExportNotice(forceHide = false) {
      if (!exportNoticeEl) return;
      if (forceHide || !docType) {
        clearExportNotice();
        return;
      }
      if (docType === 'pdf' && pageCount > 1 && exportModeEl.value === 'png-single') {
        const widthText = SINGLE_IMAGE_TARGET_WIDTH.toLocaleString('es-ES');
        const heightText = SINGLE_IMAGE_MAX_HEIGHT.toLocaleString('es-ES');
        exportNoticeEl.textContent = `Generará una única imagen PNG apilando las ${pageCount} páginas (ancho máximo ${widthText}px y alto limitado a ${heightText}px para que la IA lea el contenido). Puede tardar unos segundos.`;
        exportNoticeEl.style.display = 'block';
      } else {
        clearExportNotice();
      }
    }

    function clearExportNotice() {
      if (!exportNoticeEl) return;
      exportNoticeEl.textContent = '';
      exportNoticeEl.style.display = 'none';
    }

    function toggleApplyAllState() {
      const multiplePages = docType === 'pdf' && pageCount > 1;
      applyAllEl.disabled = !multiplePages;
      if (!multiplePages) {
        applyAllEl.checked = false;
      }
    }

    function resetViewerState() {
      rectsByPage = {};
      pageViews.clear();
      pageStates.clear();
      observer?.disconnect();
      pagesContainer.innerHTML = '';
      activePage = 1;
      pageCount = 0;
      docType = null;
      pageNumEl.textContent = '-';
      pageCountEl.textContent = '-';
      btnClearRects.disabled = true;
      resetExportControls();
      setZoomControlsEnabled(false);
      toggleApplyAllState();
    }

    async function openDocument(file) {
      if (!file) return false;
      const name = file.name || 'documento';
      const lowerName = name.toLowerCase();
      const type = (file.type || '').toLowerCase();
      const isPdf = type === 'application/pdf' || lowerName.endsWith('.pdf');
      const isImage = type.startsWith('image/') || SUPPORTED_IMAGE_REGEX.test(lowerName);

      if (!isPdf && !isImage) {
        alert('Selecciona un archivo PDF o una imagen (PNG, JPG, WEBP…).');
        fileDropText.textContent = DEFAULT_DROP_TEXT;
        return false;
      }

      if (isPdf) {
        let arrayBuf;
        try {
          arrayBuf = await file.arrayBuffer();
        } catch (err) {
          console.error('No se pudo leer el archivo soltado/seleccionado.', err);
          alert('No se pudo leer el archivo. Prueba con otro PDF.');
          fileDropText.textContent = DEFAULT_DROP_TEXT;
          return false;
        }
        const loaded = await loadPdfFromArrayBuffer(arrayBuf, name);
        fileDropText.textContent = loaded ? name : DEFAULT_DROP_TEXT;
        return loaded;
      }

      const loaded = await loadImageDocument(file);
      fileDropText.textContent = loaded ? name : DEFAULT_DROP_TEXT;
      return loaded;
    }

    async function loadPdfFromArrayBuffer(arrayBuf, fileName = 'documento.pdf') {
      const targetName = forceExtension(sanitizeFileName(fileName), '.pdf');
      const loadingTask = pdfjsLib.getDocument({
        data: arrayBuf,
        cMapUrl: './vendor/pdfjs/cmaps/',
        cMapPacked: true,
        standardFontDataUrl: './vendor/pdfjs/standard_fonts/'
      });
      try {
        pdfDoc = await loadingTask.promise;
      } catch (err) {
        console.error('Error cargando PDF', err);
        alert('No se pudo abrir el PDF: ' + (err && err.message ? err.message : err));
        return false;
      }
      resetViewerState();

      currentFileName = targetName;

      docType = 'pdf';
      imageDoc = null;

      const firstPage = await pdfDoc.getPage(1);
      const baseViewport = firstPage.getViewport({ scale: 1 });
      basePageWidth = baseViewport.width;
      fitScale = computeScaleForWidth(basePageWidth);
      scale = fitScale * zoomFactor;

      pageCount = pdfDoc.numPages;

      await renderPage(1, firstPage);
      for (let p = 2; p <= pdfDoc.numPages; p++) {
        await renderPage(p);
      }

      pageCountEl.textContent = pdfDoc.numPages;
      setActivePage(1);
      updateClearButtonState();
      configureExportForDoc('pdf');
      setZoomControlsEnabled(true);
      updateZoomDisplay();
      toggleApplyAllState();
      return true;
    }

    async function loadImageDocument(file) {
      const fallbackExt = guessImageExtension(file);
      let objectUrl = '';
      let image;
      try {
        objectUrl = URL.createObjectURL(file);
        image = await loadImageElement(objectUrl);
      } catch (err) {
        console.error('No se pudo cargar la imagen seleccionada.', err);
        alert('No se pudo abrir la imagen. Prueba con otro archivo.');
        if (objectUrl) URL.revokeObjectURL(objectUrl);
        return false;
      }
      if (objectUrl) {
        URL.revokeObjectURL(objectUrl);
      }
      if (!image) {
        alert('No se pudo abrir la imagen.');
        return false;
      }
      const width = image.naturalWidth || image.width;
      const height = image.naturalHeight || image.height;
      if (!width || !height) {
        alert('No se pudo determinar el tamaño de la imagen.');
        return false;
      }

      resetViewerState();

      currentFileName = ensureExtension(sanitizeFileName(file.name), fallbackExt);

      docType = 'image';
      pdfDoc = null;
      imageDoc = { image, width, height };
      basePageWidth = width;
      fitScale = computeScaleForWidth(basePageWidth);
      scale = fitScale * zoomFactor;
      pageCount = 1;

      await renderPage(1, imageDoc);
      pageCountEl.textContent = '1';
      setActivePage(1);
      updateClearButtonState();
      configureExportForDoc('image');
      setZoomControlsEnabled(true);
      updateZoomDisplay();
      toggleApplyAllState();
      return true;
    }

    async function renderPage(pageNumber, pageInstance) {
      if (!docType) return;
      let view = pageViews.get(pageNumber);
      if (!view) {
        view = createPageView(pageNumber);
      }
      const { canvas, overlay, img, ctx, wrapper } = view;

      if (docType === 'pdf') {
        const page = pageInstance || await pdfDoc.getPage(pageNumber);
        const viewport = page.getViewport({ scale });
        const width = viewport.width;
        const height = viewport.height;
        canvas.width = width; canvas.height = height;
        overlay.width = width; overlay.height = height;
        img.width = width; img.height = height;
        img.style.width = overlay.style.width = width + 'px';
        img.style.height = overlay.style.height = height + 'px';
        wrapper.style.width = width + 'px';
        wrapper.style.height = height + 'px';
        await page.render({ canvasContext: ctx, viewport }).promise;
      } else if (docType === 'image' && imageDoc) {
        const width = imageDoc.width * scale;
        const height = imageDoc.height * scale;
        const canvasWidth = Math.max(1, Math.round(width));
        const canvasHeight = Math.max(1, Math.round(height));
        canvas.width = canvasWidth;
        canvas.height = canvasHeight;
        overlay.width = canvasWidth;
        overlay.height = canvasHeight;
        img.width = canvasWidth;
        img.height = canvasHeight;
        const displayWidth = canvasWidth + 'px';
        const displayHeight = canvasHeight + 'px';
        img.style.width = overlay.style.width = displayWidth;
        img.style.height = overlay.style.height = displayHeight;
        wrapper.style.width = displayWidth;
        wrapper.style.height = displayHeight;
        ctx.clearRect(0, 0, canvasWidth, canvasHeight);
        ctx.drawImage(imageDoc.image, 0, 0, canvasWidth, canvasHeight);
      }

      img.src = canvas.toDataURL('image/png');
      drawOverlay(pageNumber);
    }

    function createPageView(pageNumber) {
      const wrapper = document.createElement('div');
      wrapper.className = 'pageView';
      wrapper.dataset.page = String(pageNumber);

      const canvas = document.createElement('canvas');
      canvas.className = 'pdfPageCanvas';

      const img = document.createElement('img');
      img.className = 'pdfPageImage';
      img.draggable = false;

      const overlay = document.createElement('canvas');
      overlay.className = 'pdfOverlay';

      wrapper.append(img, overlay, canvas);
      pagesContainer.appendChild(wrapper);
      observer?.observe(wrapper);

      const view = {
        wrapper,
        canvas,
        img,
        overlay,
        ctx: canvas.getContext('2d'),
        octx: overlay.getContext('2d')
      };

      setupOverlayInteractions(pageNumber, view);
      pageViews.set(pageNumber, view);
      return view;
    }

    function setupOverlayInteractions(pageNumber, view) {
      const { overlay } = view;
      overlay.addEventListener('mousedown', (e) => {
        if (e.button !== 0 && e.button !== 2) return;
        e.preventDefault();
        const state = getPageState(pageNumber);
        const { x, y } = getMousePos(e, overlay);
        state.drawing = true;
        state.startX = x;
        state.startY = y;
        state.previewRect = null;
        state.button = e.button;
        state.applyAll = docType === 'pdf' && pageCount > 1 && e.button === 2;
        setActivePage(pageNumber);
      });

      overlay.addEventListener('mousemove', (e) => {
        const state = getPageState(pageNumber);
        if (!state.drawing) return;
        const { x, y } = getMousePos(e, overlay);
        state.previewRect = normalizeRect(state.startX, state.startY, x, y);
        drawOverlay(pageNumber);
      });

      const endDrawing = () => {
      const state = getPageState(pageNumber);
      if (!state.drawing) return;
      state.drawing = false;
      if (!rectsByPage[pageNumber]) rectsByPage[pageNumber] = [];
      const rect = state.previewRect;
      if (rect && rect.w > 4 && rect.h > 4) {
        rectsByPage[pageNumber].push({ ...rect });
        const applyAll = (docType === 'pdf' && pageCount > 1) && (applyAllEl.checked || state.applyAll);
        if (applyAll) {
          applyRectToAllPages(rect, pageNumber);
        }
      }
      state.previewRect = null;
      state.applyAll = false;
      state.button = 0;
      drawOverlay(pageNumber);
      updateClearButtonState();
    };

      overlay.addEventListener('mouseup', endDrawing);
      overlay.addEventListener('mouseleave', endDrawing);
      overlay.addEventListener('contextmenu', (e) => {
        e.preventDefault();
      });

      overlay.addEventListener('dblclick', () => {
        const list = rectsByPage[pageNumber] || [];
        list.pop();
        rectsByPage[pageNumber] = list;
        drawOverlay(pageNumber);
        updateClearButtonState();
      });
    }

    function getPageState(pageNumber) {
      if (!pageStates.has(pageNumber)) {
        pageStates.set(pageNumber, {
          drawing: false,
          startX: 0,
          startY: 0,
          previewRect: null,
          applyAll: false,
          button: 0
        });
      }
      return pageStates.get(pageNumber);
    }

    function drawOverlay(pageNumber) {
      const view = pageViews.get(pageNumber);
      if (!view) return;
      const { overlay, octx } = view;
      octx.clearRect(0, 0, overlay.width, overlay.height);
      const mask = maskColorEl.value || '#000';
      const alpha = Math.max(0.1, Math.min(1, Number(opacityEl.value) || 1));
      const strokeW = Number(strokeWEl.value) || 2;
      const rects = rectsByPage[pageNumber] || [];
      const preview = pageStates.get(pageNumber)?.previewRect || null;

      octx.save();
      for (const rect of rects) paintRect(octx, rect, mask, alpha, strokeW);
      if (preview) paintRect(octx, preview, mask, alpha, strokeW);
      octx.restore();
    }

    function paintRect(ctx, rect, mask, alpha, strokeW) {
      ctx.globalAlpha = alpha;
      ctx.fillStyle = mask;
      ctx.fillRect(rect.x, rect.y, rect.w, rect.h);
      ctx.globalAlpha = 1;
      ctx.lineWidth = strokeW;
      ctx.strokeStyle = '#000';
      ctx.strokeRect(rect.x, rect.y, rect.w, rect.h);
    }

    function redrawAllOverlays() {
      for (const pageNumber of pageViews.keys()) {
        drawOverlay(pageNumber);
      }
    }

    function updateZoomDisplay() {
      if (zoomDisplay) {
        zoomDisplay.textContent = `${Math.round(zoomFactor * 100)}%`;
      }
      const canZoom = !!docType;
      zoomInBtn.disabled = !canZoom || zoomFactor >= (MAX_ZOOM - 0.01);
      zoomOutBtn.disabled = !canZoom || zoomFactor <= (MIN_ZOOM + 0.01);
      zoomFitBtn.disabled = !canZoom;
    }

    function setZoomControlsEnabled(enabled) {
      if (!enabled) {
        zoomInBtn.disabled = true;
        zoomOutBtn.disabled = true;
        zoomFitBtn.disabled = true;
      } else {
        updateZoomDisplay();
      }
    }

    async function setZoomFactor(newFactor) {
      const clamped = clamp(newFactor, MIN_ZOOM, MAX_ZOOM);
      if (Math.abs(clamped - zoomFactor) < 0.001) {
        updateZoomDisplay();
        return;
      }
      zoomFactor = clamped;
      localStorage.setItem(ZOOM_KEY, zoomFactor.toFixed(2));
      updateZoomDisplay();
      if (!docType) return;
      await applyScale();
    }

    async function applyScale() {
      const newScale = fitScale * zoomFactor;
      const factor = newScale / scale;
      scale = newScale;
      if (Math.abs(factor - 1) > 0.001) {
        rescaleRects(factor);
      }
      for (const state of pageStates.values()) {
        state.drawing = false;
        state.previewRect = null;
      }
      await rerenderAllPages();
      redrawAllOverlays();
    }

    function rescaleRects(factor) {
      for (const key of Object.keys(rectsByPage)) {
        const arr = rectsByPage[key];
        if (!Array.isArray(arr)) continue;
        rectsByPage[key] = arr.map((rect) => ({
          x: rect.x * factor,
          y: rect.y * factor,
          w: rect.w * factor,
          h: rect.h * factor,
        }));
      }
    }

    function applyRectToAllPages(rect, sourcePage) {
      if (docType !== 'pdf' || pageCount <= 1) return;
      for (let p = 1; p <= pageCount; p++) {
        if (p === sourcePage) continue;
        if (!rectsByPage[p]) rectsByPage[p] = [];
        rectsByPage[p].push({ ...rect });
        if (pageViews.has(p)) {
          drawOverlay(p);
        }
      }
    }

    async function rerenderAllPages() {
      if (!docType) return;
      for (let pageNum = 1; pageNum <= pageCount; pageNum++) {
        await renderPage(pageNum);
      }
    }

    function setActivePage(pageNumber) {
      if (!pageViews.has(pageNumber)) return;
      activePage = pageNumber;
      pageNumEl.textContent = pageNumber;
      for (const [num, view] of pageViews.entries()) {
        view.wrapper.classList.toggle('active', num === pageNumber);
      }
      updateClearButtonState();
    }

    function updateClearButtonState() {
      if (!docType) {
        btnClearRects.disabled = true;
        return;
      }
      const rects = rectsByPage[activePage] || [];
      btnClearRects.disabled = rects.length === 0;
    }

    function computeScaleForWidth(pageWidth) {
      const containerWidth = viewerContainer.clientWidth || viewerContainer.getBoundingClientRect().width;
      if (!containerWidth) return 1;
      const available = Math.max(containerWidth - 24, 200);
      const fitScale = available / pageWidth;
      if (!Number.isFinite(fitScale) || fitScale <= 0) return 1;
      return Math.min(1.3, fitScale);
    }

    function clamp(value, min, max) {
      return Math.min(max, Math.max(min, value));
    }

    window.addEventListener('resize', () => {
      if (!docType || !basePageWidth) return;
      clearTimeout(resizeTimeout);
      resizeTimeout = setTimeout(async () => {
        const newFit = computeScaleForWidth(basePageWidth);
        if (!Number.isFinite(newFit) || newFit <= 0) return;
        const prevScale = scale;
        fitScale = newFit;
        const newScale = fitScale * zoomFactor;
        const factor = newScale / prevScale;
        scale = newScale;
        if (Math.abs(factor - 1) > 0.001) {
          rescaleRects(factor);
        }
        await rerenderAllPages();
        redrawAllOverlays();
        updateZoomDisplay();
      }, 180);
    });

    function normalizeExtension(ext, defaultExt = '') {
      if (!ext) return defaultExt;
      return ext.startsWith('.') ? ext : `.${ext}`;
    }

    function sanitizeFileName(name) {
      if (!name || typeof name !== 'string') return 'documento';
      const invalid = /[\\/:*?"<>|]+/g;
      const cleaned = name.replace(invalid, '_').trim();
      return cleaned || 'documento';
    }

    function ensureExtension(name, ext) {
      const normalizedExt = normalizeExtension(ext, '');
      if (!normalizedExt) return name;
      if (/\.[^.]+$/.test(name)) {
        return name;
      }
      return `${name}${normalizedExt}`;
    }

    function forceExtension(name, ext) {
      const normalizedExt = normalizeExtension(ext, '');
      if (!normalizedExt) return name;
      const base = name.replace(/\.[^.]+$/, '');
      return `${base}${normalizedExt}`;
    }

    function buildAnonName(original, fallbackExt = '.pdf') {
      const normalizedExt = normalizeExtension(fallbackExt, '.pdf');
      if (namingStrategy === 'fixed') {
        return `anonim${normalizedExt}`;
      }
      const safeName = sanitizeFileName(original);
      const match = safeName.match(/(\.[^.]+)$/);
      const base = match ? safeName.slice(0, -match[0].length) : safeName;
      const ext = normalizedExt || (match ? match[0] : '');
      return `${base}_anonim${ext}`;
    }

    function guessImageExtension(file) {
      const type = (file && file.type ? file.type : '').toLowerCase();
      if (type) {
        if (type === 'image/jpeg') return '.jpg';
        if (type.startsWith('image/')) {
          const subtype = type.slice(6);
          const clean = subtype.includes('+') ? subtype.split('+')[0] : subtype;
          return normalizeExtension(clean);
        }
      }
      const name = (file && file.name ? file.name : '').toLowerCase();
      const match = name.match(/(\.[a-z0-9]{2,5})$/);
      if (match) return match[1];
      return '.png';
    }

    function loadImageElement(url) {
      return new Promise((resolve, reject) => {
        const img = new Image();
        img.onload = () => resolve(img);
        img.onerror = (err) => reject(err);
        img.src = url;
      });
    }

    function getMousePos(e, el) {
      const rect = el.getBoundingClientRect();
      const x = (e.clientX - rect.left) * (el.width / rect.width);
      const y = (e.clientY - rect.top) * (el.height / rect.height);
      return { x, y };
    }

    function normalizeRect(x1, y1, x2, y2) {
      const x = Math.min(x1, x2);
      const y = Math.min(y1, y2);
      const w = Math.abs(x2 - x1);
      const h = Math.abs(y2 - y1);
      return { x, y, w, h };
    }

  });
</script>
</body>
</html>
