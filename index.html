<!doctype html>
<!--
  Anonimizador de PDF — Copyright (C) 2025 Juan José de Haro
  Licencia del código: GNU Affero General Public License v3.0 (AGPL-3.0)
-->
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="icon" type="image/svg+xml" href="./favicon.svg" />
  <title>Anonimizador de PDF e imágenes — cliente</title>
  <style>
    :root { color-scheme: light dark; }
    * { box-sizing: border-box; }
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Arial, "Apple Color Emoji", "Segoe UI Emoji"; margin: 0; }
    header { position: sticky; top: 0; padding: .75rem 1rem; border-bottom: 1px solid #8883; backdrop-filter: blur(6px); }
    main { display: grid; grid-template-columns: 360px 1fr; gap: 1rem; padding: 1rem; transition: grid-template-columns .35s ease; }
    @media (max-width: 900px){ main { grid-template-columns: 1fr; } }
    .panel { border: 1px solid #8884; border-radius: .75rem; padding: .75rem; background: color-mix(in srgb, canvas 96%, canvastext 4%); }
    .langSelector { margin-left: auto; display: flex; align-items: center; gap: .4rem; font-size: .9rem; }
    .langSelector span { font-weight: 600; }
    .langSelector select { padding: .4rem .6rem; border-radius: .5rem; min-width: 7rem; }
    .row { display: flex; gap: .5rem; flex-wrap: wrap; align-items: center; }
    button, input[type="number"], input[type="file"], select { padding: .5rem .6rem; border-radius: .5rem; border: 1px solid #8884; background: inherit; }
    button { cursor: pointer; }
    .panelToggle { width: 2.4rem; height: 2.4rem; border-radius: 50%; display: inline-flex; align-items: center; justify-content: center; padding: 0; border: 1px solid color-mix(in srgb, #16a34a 35%, transparent 65%); background: color-mix(in srgb, canvas 93%, #16a34a 7%); color: color-mix(in srgb, canvastext 88%, #0f2716 12%); box-shadow: 0 1px 4px #0002; transition: background .2s ease, color .2s ease, transform .2s ease; flex: 0 0 2.4rem; position: relative; }
    .panelToggle svg { width: 1.35rem; height: 1.35rem; }
    #toggleControls .icon-show { display: none; }
    body.controlsHidden #toggleControls .icon-hide { display: none; }
    body.controlsHidden #toggleControls .icon-show { display: block; }
    .panelToggle:hover { background: color-mix(in srgb, canvas 88%, #16a34a 12%); }
    .panelToggle:focus-visible { outline: 2px solid #16a34a; outline-offset: 2px; }
    #export { font-weight: 600; background: #5cb85c; border-color: #4aa34a; color: #ffffff; }
    #export:hover:not(:disabled) { background: #4aa34a; border-color: #3f8d3f; }
    #btnClearRects { background: color-mix(in srgb, canvas 90%, #16a34a 10%); border-color: color-mix(in srgb, #16a34a 22%, transparent 78%); color: color-mix(in srgb, canvastext 90%, #0f2716 10%); }
    #export:disabled,
    #btnClearRects:disabled { opacity: .6; cursor: not-allowed; }
    .fileDrop { flex: 1 1 200px; display: flex; align-items: center; justify-content: center; gap: .5rem; border: 1px dashed color-mix(in srgb, canvastext 40%, transparent 60%); border-radius: .65rem; padding: .6rem .75rem; min-height: 3.25rem; background: color-mix(in srgb, canvas 94%, #16a34a 6%); cursor: pointer; transition: border-color .2s ease, background .2s ease, color .2s ease; text-align: center; }
    .fileDrop.hasFile { background: inherit; border-style: solid; border-color: color-mix(in srgb, #5cb85c 55%, transparent 45%); color: #5cb85c; font-weight: 600; }
    .fileDrop.hasFile:hover { border-color: color-mix(in srgb, #4aa34a 60%, transparent 40%); background: inherit; color: #4aa34a; }
    .fileDrop:hover { border-color: color-mix(in srgb, #16a34a 55%, transparent 45%); background: color-mix(in srgb, canvas 90%, #16a34a 10%); }
    .fileDrop.dragging { border-color: color-mix(in srgb, #16a34a 70%, transparent 30%); background: color-mix(in srgb, canvas 85%, #16a34a 15%); color: color-mix(in srgb, canvastext 92%, #0f2716 8%); }
    .fileDropInput { display: none; }
    .muted { opacity: .8; font-size: .92rem; }
    .kbd { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace; background: #8882; border: 1px solid #8884; padding: 0 .35rem; border-radius: .35rem; }
    fieldset { border: none; margin: 0; padding: 0; }
    .namingField { display: flex; gap: .75rem; flex-wrap: wrap; align-items: center; }
    .namingField legend { font-size: .92rem; font-weight: 600; margin-right: .25rem; }
    .namingField label { display: inline-flex; align-items: center; gap: .35rem; }
    .rectSettings { border: 1px solid color-mix(in srgb, canvastext 22%, transparent 78%); border-radius: .65rem; padding: .6rem .75rem; margin-bottom: .75rem; background: color-mix(in srgb, canvas 92%, canvastext 8%); }
    .rectSettings legend { font-size: .92rem; font-weight: 600; padding: 0 .35rem; }
    .rectSettings .rectControls { display: flex; gap: .75rem; flex-wrap: wrap; align-items: flex-start; }
    .rectSettings .rectStack { display: flex; flex-direction: column; gap: .4rem; min-width: 11rem; }
    .panelControls { position: relative; transition: transform .35s ease, opacity .25s ease; background: color-mix(in srgb, canvas 92%, canvastext 8%); }
    .panelTopRow { align-items: stretch; }
    .panelTopRow .fileDrop { flex: 1 1 auto; }
    #viewerContainer { position: relative; overflow-y: auto; max-height: 75vh; padding: 1rem .5rem .5rem; }
    #pagesContainer { display: flex; flex-direction: column; gap: 1.5rem; align-items: center; }
    .viewerToolbar { position: sticky; top: .75rem; z-index: 6; display: flex; align-items: center; justify-content: center; gap: .75rem; padding: 0 1.5rem; margin-bottom: .25rem; }
    #showControls { position: absolute; left: 1.25rem; top: 50%; transform: translate(-50%, -50%); opacity: 0; visibility: hidden; pointer-events: none; transition: opacity .2s ease; }
    #zoomOverlay { display: inline-flex; align-items: center; gap: .5rem; padding: .35rem .6rem; border-radius: .6rem; border: 1px solid #8886; box-shadow: 0 6px 16px #0005; background: color-mix(in srgb, canvas 65%, #222 35%); backdrop-filter: blur(6px); }
    #zoomOverlay button { background: color-mix(in srgb, canvas 55%, #000 45%); color: inherit; border-radius: .5rem; border: 1px solid #8886; min-width: 2.1rem; }
    body.controlsHidden main { grid-template-columns: 0px 1fr; }
    body.controlsHidden .panelControls { transform: translateX(-2rem); opacity: 0; pointer-events: none; }
    body.controlsHidden #showControls { opacity: 1; visibility: visible; pointer-events: auto; }
    @media (prefers-color-scheme: light) {
      .panelControls { background: #f2f3f5; }
      .panel { background: #f9fafb; }
      #zoomOverlay { background: color-mix(in srgb, canvas 95%, #666 5%); border-color: color-mix(in srgb, #000 18%, transparent 82%); box-shadow: 0 6px 18px #0002; }
      #zoomOverlay button { background: color-mix(in srgb, canvas 98%, #666 2%); border-color: color-mix(in srgb, #000 25%, transparent 75%); color: color-mix(in srgb, canvastext 92%, #000 8%); }
      #zoomOverlay button:disabled { opacity: .55; }
    }
    #zoomOverlay button:disabled { opacity: .45; }
    .pageView { position: relative; }
    .pageView img { display: block; border: 1px solid #8884; border-radius: .5rem; background: #fff; user-select: none; }
    .pageView .pdfPageCanvas { display: none; }
    .pageView .pdfOverlay { position: absolute; inset: 0; pointer-events: auto; border-radius: .5rem; cursor: crosshair; z-index: 2; display: block; }
    .pageView.active { outline: 2px solid #16a34a; outline-offset: 6px; }
    .badget { font-size: .85rem; opacity: .8; }
    footer { padding: .75rem 1rem; border-top: 1px solid #8883; }
    #profModal { position: fixed; inset: 0; display: flex; align-items: center; justify-content: center; background: color-mix(in srgb, #000 55%, transparent 45%); backdrop-filter: blur(4px); padding: 1.5rem; z-index: 999; opacity: 0; pointer-events: none; transition: opacity .25s ease; }
    #profModal.active { opacity: 1; pointer-events: auto; }
    #profModal .modalDialog { max-width: 640px; width: min(100%, 640px); background: color-mix(in srgb, canvas 92%, #16a34a 8%); color: inherit; border: 1px solid color-mix(in srgb, #16a34a 35%, transparent 65%); border-radius: .9rem; box-shadow: 0 14px 32px #0006; padding: 1.2rem 1.4rem 1.5rem; display: flex; flex-direction: column; gap: .85rem; position: relative; }
    #profModal h2 { margin: 0; font-size: 1.2rem; }
    #profModal p { margin: 0; line-height: 1.55; }
    #profModal button.modalClose { align-self: flex-end; border: none; background: none; color: inherit; font-size: .95rem; cursor: pointer; padding: .35rem .6rem; border-radius: .5rem; transition: background .2s ease; }
    #profModal button.modalClose:hover { background: color-mix(in srgb, canvas 85%, #16a34a 15%); }
    .infoLink { color: inherit; text-decoration: underline; font-size: .9rem; cursor: pointer; border: none; background: none; padding: 0; }
    .panelInfoLink { margin-left: .35rem; align-self: center; }
  </style>
  <!-- Bibliotecas locales para funcionar sin conexión -->
  <script src="./vendor/pdfjs/pdf.v216.min.js" defer></script>
  <script src="./vendor/jspdf/jspdf.umd.min.js" defer></script>
  <script src="./vendor/jszip/jszip.min.js" defer></script>
</head>
<body>
  <header class="row">
    <img src="./favicon.svg" alt="" width="32" height="32" aria-hidden="true" />
    <strong data-i18n="app.headerTitle">Anonimizador de PDF e imágenes</strong>
    <label for="languageSelect" class="langSelector">
      <span data-i18n="lang.label">Idioma</span>
      <select id="languageSelect">
        <option value="es">Español</option>
        <option value="ca">Català</option>
        <option value="gl">Galego</option>
        <option value="eu">Euskara</option>
        <option value="en">English</option>
      </select>
    </label>
  </header>

  <main>
    <section class="panel panelControls">
      <div class="row panelTopRow" style="margin-bottom:.5rem">
        <button id="toggleControls" class="panelToggle panelToggle-collapse" type="button" aria-pressed="false" title="Ocultar panel de controles">
          <svg class="icon-hide" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
            <rect x="3" y="3" width="6" height="18" rx="2" />
            <path d="M14 8l-4 4 4 4" />
          </svg>
          <svg class="icon-show" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
            <rect x="3" y="3" width="2" height="18" rx="1" />
            <path d="M10 8l4 4-4 4" />
          </svg>
        </button>
        <button id="openProfModal" class="infoLink panelInfoLink" type="button" data-i18n="info.noticeButton">Aviso importante</button>
        <div id="fileDrop" class="fileDrop">
          <input id="file" class="fileDropInput" type="file" accept="application/pdf,image/*" />
          <span data-i18n="drop.default">Arrastra un PDF o imagen o haz clic para abrirlo</span>
        </div>
      </div>
      <div class="row" style="margin-bottom:.5rem; justify-content:flex-start">
        <div><span data-i18n="status.page">Página</span> <span id="pageNum">-</span><span> / </span><span id="pageCount">-</span></div>
      </div>
      <fieldset class="rectSettings" style="margin-bottom:.75rem">
        <legend data-i18n="controls.usage.title">Uso</legend>
        <p class="muted" style="margin:0" data-i18n="controls.usage.help">Arrastra con el ratón para definir rectángulos sobre el nombre. Selecciona con el botón derecho para aplicar el mismo rectángulo a todas las páginas del PDF. Doble clic borra el último rectángulo.</p>
      </fieldset>
      <fieldset class="rectSettings">
        <legend data-i18n="controls.rect.title">Dibujo del rectángulo</legend>
        <div class="rectControls">
          <label>
            <span data-i18n="controls.rect.stroke">Grosor del borde:</span>
            <input id="strokeW" type="number" min="1" max="8" value="2" style="width:4.5rem" />
          </label>
          <div class="rectStack">
            <label>
              <span data-i18n="controls.rect.opacity">Opacidad tapa:</span>
              <input id="opacity" type="number" min="0.1" max="1" step="0.1" value="1" style="width:4.5rem" />
            </label>
          </div>
          <select id="maskColor" title="Color de la máscara" data-i18n-attr-title="controls.rect.colorTitle">
            <option value="#000000" selected data-i18n="controls.rect.color.black">Negro</option>
            <option value="#ffffff" data-i18n="controls.rect.color.white">Blanco</option>
            <option value="#888888" data-i18n="controls.rect.color.gray">Gris</option>
          </select>
        </div>
      </fieldset>
      <button id="btnClearRects" disabled style="margin-bottom:.75rem" data-i18n="controls.clearButton">Limpiar rectángulos de esta página</button>
      <fieldset class="namingField" style="margin-bottom:.75rem">
        <legend data-i18n="naming.legend">Nombre del archivo exportado</legend>
        <label>
          <input type="radio" name="namingOption" value="derived" checked />
          <span data-i18n="naming.option.derived">Mismo nombre + _anonim</span>
        </label>
        <label>
          <input type="radio" name="namingOption" value="fixed" />
          <span data-i18n="naming.option.fixed">anonim.pdf</span>
        </label>
      </fieldset>
      <div class="row" style="margin-bottom:.5rem">
        <button id="export" disabled data-i18n="export.button.default">Exportar anonimizado</button>
        <select id="exportMode" aria-label="Formato de exportación" disabled style="min-width:12rem" data-i18n-attr-aria-label="export.selector.label">
          <option value="pdf" data-i18n="export.mode.pdf">PDF anonimizado</option>
          <option value="zip" data-i18n="export.mode.zip">ZIP con un PNG por página</option>
          <option value="png" data-i18n="export.mode.pngImage">Imagen PNG anonimizada</option>
        </select>
        <a id="dlLink" download style="display:none"></a>
      </div>
      <p id="exportNotice" class="muted" style="display:none; margin-top:-.25rem; margin-bottom:.75rem;"></p>
      <details>
        <summary data-i18n="details.security.title">Notas sobre seguridad del anonimizado</summary>
        <ul>
          <li data-i18n="details.security.item1">La exportación genera un PDF de imágenes (rasterizado). El texto original desaparece: ya no es seleccionable ni extraíble como texto.</li>
          <li data-i18n="details.security.item2">Esto es adecuado para ocultar nombres propios de trabajos entregados, con la contrapartida de mayor tamaño y pérdida de accesibilidad.</li>
          <li data-i18n="details.security.item3">Uso totalmente local en tu navegador.</li>
        </ul>
      </details>

      <details>
        <summary data-i18n="details.credits.title">Créditos y soporte</summary>
        <p class="muted" data-i18n="details.credits.contact" data-i18n-type="html">¿Dudas o sugerencias? Pulsa el botón verde <a href="https://github.com/jjdeharo/anonim-pdf/issues" style="color:inherit; text-decoration:underline;">New issue</a> en GitHub.</p>
        <p class="muted" data-i18n="details.credits.owner" data-i18n-type="html">Anonimizador de PDF · © 2025 <a href="https://bilateria.es" style="color:inherit; text-decoration:underline;">Juan José de Haro</a> · Recurso: <a href="https://github.com/jjdeharo/anonim-pdf" style="color:inherit; text-decoration:underline;">github.com/jjdeharo/anonim-pdf</a></p>
        <p class="muted" data-i18n="details.credits.license" data-i18n-type="html"><a href="./LICENSE.txt" style="color:inherit; text-decoration:underline;">Licencia del código: AGPL v3</a></p>
      </details>

    </section>

    <section class="panel panelViewer">
      <div class="viewerToolbar">
        <button id="showControls" class="panelToggle panelToggle-show" type="button" aria-pressed="false" title="Mostrar panel de controles">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
            <rect x="3" y="3" width="2" height="18" rx="1" />
            <path d="M10 8l4 4-4 4" />
          </svg>
        </button>
        <div id="zoomOverlay">
          <span data-i18n="viewer.zoom.label">Zoom:</span>
          <button id="zoomOut" type="button" disabled>-</button>
          <span id="zoomDisplay">100%</span>
          <button id="zoomIn" type="button" disabled>+</button>
          <button id="zoomFit" type="button" disabled data-i18n="viewer.zoom.fit">Ajustar ancho</button>
        </div>
      </div>
      <div id="viewerContainer">
        <div id="pagesContainer"></div>
      </div>
    </section>
  </main>

  <div id="profModal" role="dialog" aria-modal="true" aria-labelledby="profModalTitle" aria-describedby="profModalBody">
    <div class="modalDialog">
      <button id="closeProfModal" class="modalClose" type="button" data-i18n="modal.close">Cerrar aviso</button>
      <h2 id="profModalTitle" data-i18n="modal.title">Aviso importante</h2>
      <div id="profModalBody" style="display:flex; flex-direction:column; gap:1rem;">
        <p data-i18n="modal.body1" data-i18n-type="html"><strong>Esta aplicación únicamente genera un PDF anonimizado</strong>, ocultando los datos identificativos del alumnado para que los documentos puedan emplearse en herramientas de inteligencia artificial sin exponer información personal.</p>
        <p data-i18n="modal.body2" data-i18n-type="html">La inteligencia artificial puede servir de apoyo para obtener análisis parciales, detectar patrones o aportar nuevas perspectivas sobre los trabajos del alumnado. <strong>No debe confundirse su uso con la función docente</strong>: la IA no evalúa, no corrige y no puede asumir la responsabilidad educativa.</p>
        <p data-i18n="modal.body3" data-i18n-type="html"><strong>La evaluación, el juicio pedagógico y la calificación del alumnado corresponden siempre al profesorado.</strong> La IA puede complementar la reflexión, pero nunca sustituir el criterio profesional ni la decisión final del docente.</p>
      </div>
    </div>
  </div>

  <footer class="muted"></footer>

<script>
  window.addEventListener('DOMContentLoaded', () => {
    const LANG_STORAGE_KEY = 'anonim-pdf-lang';
    const SUPPORTED_LOCALES = ['es', 'ca', 'gl', 'eu', 'en'];
    const FALLBACK_LOCALE = 'es';
    const LOCALE_INTL = { es: 'es-ES', ca: 'ca-ES', gl: 'gl-ES', eu: 'eu-ES', en: 'en' };
    const TRANSLATIONS = {
      es: {
        'app.windowTitle': `Anonimizador de PDF e imágenes — cliente`,
        'app.headerTitle': `Anonimizador de PDF e imágenes`,
        'lang.label': `Idioma`,
        'info.noticeButton': `Aviso importante`,
        'drop.default': `Arrastra un PDF o imagen o haz clic para abrirlo`,
        'status.page': `Página`,
        'controls.usage.title': `Uso`,
        'controls.usage.help': `Arrastra con el ratón para definir rectángulos sobre el nombre. Selecciona con el botón derecho para aplicar el mismo rectángulo a todas las páginas del PDF. Doble clic borra el último rectángulo.`,
        'controls.rect.title': `Dibujo del rectángulo`,
        'controls.rect.stroke': `Grosor del borde:`,
        'controls.rect.opacity': `Opacidad tapa:`,
        'controls.rect.colorTitle': `Color de la máscara`,
        'controls.rect.color.black': `Negro`,
        'controls.rect.color.white': `Blanco`,
        'controls.rect.color.gray': `Gris`,
        'controls.clearButton': `Limpiar rectángulos de esta página`,
        'naming.legend': `Nombre del archivo exportado`,
        'naming.option.derived': `Mismo nombre + _anonim`,
        'naming.option.fixed': `anonim.pdf`,
        'export.button.default': `Exportar anonimizado`,
        'export.button.withTarget': `Exportar {target}`,
        'export.mode.pdf': `PDF anonimizado`,
        'export.mode.zip': `ZIP con un PNG por página`,
        'export.mode.pngSingle': `PNG con todas las páginas`,
        'export.mode.pngImage': `Imagen PNG anonimizada`,
        'export.selector.label': `Formato de exportación`,
        'details.security.title': `Notas sobre seguridad del anonimizado`,
        'details.security.item1': `La exportación genera un PDF de imágenes (rasterizado). El texto original desaparece: ya no es seleccionable ni extraíble como texto.`,
        'details.security.item2': `Esto es adecuado para ocultar nombres propios de trabajos entregados, con la contrapartida de mayor tamaño y pérdida de accesibilidad.`,
        'details.security.item3': `Uso totalmente local en tu navegador.`,
        'details.credits.title': `Créditos y soporte`,
        'details.credits.contact': `¿Dudas o sugerencias? Pulsa el botón verde <a href="https://github.com/jjdeharo/anonim-pdf/issues" style="color:inherit; text-decoration:underline;">New issue</a> en GitHub.`,
        'details.credits.owner': `Anonimizador de PDF · © 2025 <a href="https://bilateria.es" style="color:inherit; text-decoration:underline;">Juan José de Haro</a> · Recurso: <a href="https://github.com/jjdeharo/anonim-pdf" style="color:inherit; text-decoration:underline;">github.com/jjdeharo/anonim-pdf</a>`,
        'details.credits.license': `<a href="./LICENSE.txt" style="color:inherit; text-decoration:underline;">Licencia del código: AGPL v3</a>`,
        'viewer.zoom.label': `Zoom:`,
        'viewer.zoom.fit': `Ajustar ancho`,
        'modal.close': `Cerrar aviso`,
        'modal.title': `Aviso importante`,
        'modal.body1': `<strong>Esta aplicación únicamente genera un PDF anonimizado</strong>, ocultando los datos identificativos del alumnado para que los documentos puedan emplearse en herramientas de inteligencia artificial sin exponer información personal.`,
        'modal.body2': `La inteligencia artificial puede servir de apoyo para obtener análisis parciales, detectar patrones o aportar nuevas perspectivas sobre los trabajos del alumnado. <strong>No debe confundirse su uso con la función docente</strong>: la IA no evalúa, no corrige y no puede asumir la responsabilidad educativa.`,
        'modal.body3': `<strong>La evaluación, el juicio pedagógico y la calificación del alumnado corresponden siempre al profesorado.</strong> La IA puede complementar la reflexión, pero nunca sustituir el criterio profesional ni la decisión final del docente.`,
        'alerts.pdfjsMissing': `No se pudo cargar pdf.js. Comprueba la conexión o políticas de bloqueadores. He cambiado al build legacy para exponer "pdfjsLib".`,
        'alerts.pdfjsWorkerWarning': `Fallo al configurar worker pdf.js, usando modo sin worker.`,
        'alerts.exportError': `Ocurrió un error exportando el documento anonimizado.`,
        'alerts.exportErrorLog': `Error durante la exportación.`,
        'alerts.jsPdfMissing': `No se pudo cargar la librería jsPDF.`,
        'alerts.jsZipMissing': `No se pudo cargar la librería JSZip.`,
        'alerts.pngScaleNotice': `El PNG único se generará con menor resolución por la longitud del documento. Revisa que el resultado sea legible.`,
        'alerts.singlePngFail': `No se pudo generar la imagen única anonimizada.`,
        'alerts.imagePngFail': `No se pudo generar la imagen anonimizada.`,
        'alerts.invalidFileType': `Selecciona un archivo PDF o una imagen (PNG, JPG, WEBP…).`,
        'alerts.fileReadFailed': `No se pudo leer el archivo. Prueba con otro PDF.`,
        'alerts.pdfOpenError': `No se pudo abrir el PDF: {error}`,
        'alerts.imageOpenError': `No se pudo abrir la imagen. Prueba con otro archivo.`,
        'alerts.imageGenericError': `No se pudo abrir la imagen.`,
        'alerts.imageSizeUnknown': `No se pudo determinar el tamaño de la imagen.`,
        'alerts.pdfLoadErrorLog': `Error cargando PDF`,
        'alerts.imageLoadErrorLog': `No se pudo cargar la imagen seleccionada.`,
        'alerts.fileReadErrorLog': `No se pudo leer el archivo soltado/seleccionado.`,
        'alerts.syncInputWarn': `No se pudo sincronizar input de archivo con el drop.`,
        'controls.toggle.show': `Mostrar panel de controles`,
        'controls.toggle.hide': `Ocultar panel de controles`,
        'controls.toggle.showButton': `Mostrar panel de controles`,
        'export.notice.pngSingle': `Generará una única imagen PNG apilando las {pages} páginas (ancho máximo {width}px y alto limitado a {height}px para que la IA lea el contenido). Puede tardar unos segundos.`,
        'defaults.document': `documento`,
        'defaults.documentPdf': `documento.pdf`,
      },
      ca: {
        'app.windowTitle': `Anonimitzador de PDF i imatges — client`,
        'app.headerTitle': `Anonimitzador de PDF i imatges`,
        'lang.label': `Idioma`,
        'info.noticeButton': `Avís important`,
        'drop.default': `Arrossega un PDF o una imatge o fes clic per obrir-la`,
        'status.page': `Pàgina`,
        'controls.usage.title': `Ús`,
        'controls.usage.help': `Arrossega amb el ratolí per definir rectangles sobre el nom. Selecciona amb el botó dret per aplicar el mateix rectangle a totes les pàgines del PDF. El doble clic esborra l'últim rectangle.`,
        'controls.rect.title': `Dibuix del rectangle`,
        'controls.rect.stroke': `Gruix del contorn:`,
        'controls.rect.opacity': `Opacitat de la cobertura:`,
        'controls.rect.colorTitle': `Color de la màscara`,
        'controls.rect.color.black': `Negre`,
        'controls.rect.color.white': `Blanc`,
        'controls.rect.color.gray': `Gris`,
        'controls.clearButton': `Neteja els rectangles d'aquesta pàgina`,
        'naming.legend': `Nom del fitxer exportat`,
        'naming.option.derived': `Mateix nom + _anonim`,
        'naming.option.fixed': `anonim.pdf`,
        'export.button.default': `Exporta anonimitzat`,
        'export.button.withTarget': `Exporta {target}`,
        'export.mode.pdf': `PDF anonimitzat`,
        'export.mode.zip': `ZIP amb un PNG per pàgina`,
        'export.mode.pngSingle': `PNG amb totes les pàgines`,
        'export.mode.pngImage': `Imatge PNG anonimitzada`,
        'export.selector.label': `Format d'exportació`,
        'details.security.title': `Notes sobre la seguretat de l'anonimització`,
        'details.security.item1': `L'exportació genera un PDF d'imatges (rasteritzat). El text original desapareix: ja no és seleccionable ni es pot extreure com a text.`,
        'details.security.item2': `És adequat per ocultar noms propis de treballs entregats, amb la contrapartida d'un pes més gran i pèrdua d'accessibilitat.`,
        'details.security.item3': `Ús totalment local al teu navegador.`,
        'details.credits.title': `Crèdits i suport`,
        'details.credits.contact': `Dubtes o suggeriments? Prem el botó verd <a href="https://github.com/jjdeharo/anonim-pdf/issues" style="color:inherit; text-decoration:underline;">New issue</a> a GitHub.`,
        'details.credits.owner': `Anonimitzador de PDF · © 2025 <a href="https://bilateria.es" style="color:inherit; text-decoration:underline;">Juan José de Haro</a> · Recurs: <a href="https://github.com/jjdeharo/anonim-pdf" style="color:inherit; text-decoration:underline;">github.com/jjdeharo/anonim-pdf</a>`,
        'details.credits.license': `<a href="./LICENSE.txt" style="color:inherit; text-decoration:underline;">Llicència del codi: AGPL v3</a>`,
        'viewer.zoom.label': `Zoom:`,
        'viewer.zoom.fit': `Ajusta l'amplada`,
        'modal.close': `Tanca l'avís`,
        'modal.title': `Avís important`,
        'modal.body1': `<strong>Aquesta aplicació només genera un PDF anonimitzat</strong>, ocultant les dades identificatives de l'alumnat perquè els documents es puguin emprar en eines d'intel·ligència artificial sense exposar informació personal.`,
        'modal.body2': `La intel·ligència artificial pot servir de suport per obtenir anàlisis parcials, detectar patrons o aportar noves perspectives sobre els treballs de l'alumnat. <strong>No s'ha de confondre el seu ús amb la funció docent</strong>: la IA no avalua, no corregeix i no pot assumir la responsabilitat educativa.`,
        'modal.body3': `<strong>L'avaluació, el judici pedagògic i la qualificació de l'alumnat corresponen sempre al professorat.</strong> La IA pot complementar la reflexió, però mai substituir el criteri professional ni la decisió final del docent.`,
        'alerts.pdfjsMissing': `No s'ha pogut carregar pdf.js. Comprova la connexió o els bloquejadors. He canviat al build legacy per exposar "pdfjsLib".`,
        'alerts.pdfjsWorkerWarning': `Error en configurar el worker de pdf.js; s'utilitzarà el mode sense worker.`,
        'alerts.exportError': `S'ha produït un error en exportar el document anonimitzat.`,
        'alerts.exportErrorLog': `Error en l'exportació.`,
        'alerts.jsPdfMissing': `No s'ha pogut carregar la llibreria jsPDF.`,
        'alerts.jsZipMissing': `No s'ha pogut carregar la llibreria JSZip.`,
        'alerts.pngScaleNotice': `El PNG únic es generarà amb menys resolució per la longitud del document. Revisa que el resultat sigui llegible.`,
        'alerts.singlePngFail': `No s'ha pogut generar la imatge única anonimitzada.`,
        'alerts.imagePngFail': `No s'ha pogut generar la imatge anonimitzada.`,
        'alerts.invalidFileType': `Selecciona un fitxer PDF o una imatge (PNG, JPG, WEBP…).`,
        'alerts.fileReadFailed': `No s'ha pogut llegir el fitxer. Prova amb un altre PDF.`,
        'alerts.pdfOpenError': `No s'ha pogut obrir el PDF: {error}`,
        'alerts.imageOpenError': `No s'ha pogut obrir la imatge. Prova amb un altre fitxer.`,
        'alerts.imageGenericError': `No s'ha pogut obrir la imatge.`,
        'alerts.imageSizeUnknown': `No s'ha pogut determinar la mida de la imatge.`,
        'alerts.pdfLoadErrorLog': `Error en carregar el PDF`,
        'alerts.imageLoadErrorLog': `No s'ha pogut carregar la imatge seleccionada.`,
        'alerts.fileReadErrorLog': `No s'ha pogut llegir el fitxer arrossegat/seleccionat.`,
        'alerts.syncInputWarn': `No s'ha pogut sincronitzar l'entrada de fitxers amb l'arrossegament.`,
        'controls.toggle.show': `Mostra el panell de controls`,
        'controls.toggle.hide': `Oculta el panell de controls`,
        'controls.toggle.showButton': `Mostra el panell de controls`,
        'export.notice.pngSingle': `Generarà una única imatge PNG apilant les {pages} pàgines (amplada màxima {width}px i alçada limitada a {height}px perquè la IA en llegeixi el contingut). Pot trigar uns segons.`,
        'defaults.document': `document`,
        'defaults.documentPdf': `document.pdf`,
      },
      gl: {
        'app.windowTitle': `Anonimizador de PDF e imaxes — cliente`,
        'app.headerTitle': `Anonimizador de PDF e imaxes`,
        'lang.label': `Idioma`,
        'info.noticeButton': `Aviso importante`,
        'drop.default': `Arrastra un PDF ou unha imaxe ou fai clic para abrila`,
        'status.page': `Páxina`,
        'controls.usage.title': `Uso`,
        'controls.usage.help': `Arrastra co rato para definir rectángulos sobre o nome. Selecciona co botón dereito para aplicar o mesmo rectángulo a todas as páxinas do PDF. O dobre clic borra o último rectángulo.`,
        'controls.rect.title': `Debuxo do rectángulo`,
        'controls.rect.stroke': `Grosor do bordo:`,
        'controls.rect.opacity': `Opacidade da cuberta:`,
        'controls.rect.colorTitle': `Cor da máscara`,
        'controls.rect.color.black': `Negro`,
        'controls.rect.color.white': `Branco`,
        'controls.rect.color.gray': `Gris`,
        'controls.clearButton': `Limpar os rectángulos desta páxina`,
        'naming.legend': `Nome do ficheiro exportado`,
        'naming.option.derived': `Mesmo nome + _anonim`,
        'naming.option.fixed': `anonim.pdf`,
        'export.button.default': `Exportar anonimizado`,
        'export.button.withTarget': `Exportar {target}`,
        'export.mode.pdf': `PDF anonimizado`,
        'export.mode.zip': `ZIP cun PNG por páxina`,
        'export.mode.pngSingle': `PNG con todas as páxinas`,
        'export.mode.pngImage': `Imaxe PNG anonimizada`,
        'export.selector.label': `Formato de exportación`,
        'details.security.title': `Notas sobre a seguridade da anonimización`,
        'details.security.item1': `A exportación xera un PDF de imaxes (rasterizado). O texto orixinal desaparece: xa non é seleccionable nin extraíble como texto.`,
        'details.security.item2': `É axeitado para agochar nomes propios de traballos entregados, coa contrapartida dun maior tamaño e perda de accesibilidade.`,
        'details.security.item3': `Uso totalmente local no teu navegador.`,
        'details.credits.title': `Créditos e soporte`,
        'details.credits.contact': `Tes dúbidas ou suxestións? Preme o botón verde <a href="https://github.com/jjdeharo/anonim-pdf/issues" style="color:inherit; text-decoration:underline;">New issue</a> en GitHub.`,
        'details.credits.owner': `Anonimizador de PDF · © 2025 <a href="https://bilateria.es" style="color:inherit; text-decoration:underline;">Juan José de Haro</a> · Recurso: <a href="https://github.com/jjdeharo/anonim-pdf" style="color:inherit; text-decoration:underline;">github.com/jjdeharo/anonim-pdf</a>`,
        'details.credits.license': `<a href="./LICENSE.txt" style="color:inherit; text-decoration:underline;">Licenza do código: AGPL v3</a>`,
        'viewer.zoom.label': `Zoom:`,
        'viewer.zoom.fit': `Axustar ancho`,
        'modal.close': `Pechar aviso`,
        'modal.title': `Aviso importante`,
        'modal.body1': `<strong>Esta aplicación só xera un PDF anonimizado</strong>, ocultando os datos identificativos do alumnado para que os documentos poidan empregarse en ferramentas de intelixencia artificial sen expor información persoal.`,
        'modal.body2': `A intelixencia artificial pode servir de apoio para obter análises parciais, detectar patróns ou achegar novas perspectivas sobre os traballos do alumnado. <strong>Non se debe confundir o seu uso coa función docente</strong>: a IA non avalía, non corrixe e non pode asumir a responsabilidade educativa.`,
        'modal.body3': `<strong>A avaliación, o xuízo pedagóxico e a cualificación do alumnado corresponden sempre ao profesorado.</strong> A IA pode complementar a reflexión, pero nunca substituír o criterio profesional nin a decisión final do docente.`,
        'alerts.pdfjsMissing': `Non se puido cargar pdf.js. Comproba a conexión ou os bloqueadores. Cambiei á versión legacy para expor "pdfjsLib".`,
        'alerts.pdfjsWorkerWarning': `Produciuse un erro ao configurar o worker de pdf.js; usarase o modo sen worker.`,
        'alerts.exportError': `Produciuse un erro ao exportar o documento anonimizado.`,
        'alerts.exportErrorLog': `Erro na exportación.`,
        'alerts.jsPdfMissing': `Non se puido cargar a biblioteca jsPDF.`,
        'alerts.jsZipMissing': `Non se puido cargar a biblioteca JSZip.`,
        'alerts.pngScaleNotice': `O PNG único xeraráse cunha resolución menor pola lonxitude do documento. Revisa que o resultado sexa lexible.`,
        'alerts.singlePngFail': `Non se puido xerar a imaxe única anonimizada.`,
        'alerts.imagePngFail': `Non se puido xerar a imaxe anonimizada.`,
        'alerts.invalidFileType': `Selecciona un ficheiro PDF ou unha imaxe (PNG, JPG, WEBP…).`,
        'alerts.fileReadFailed': `Non se puido ler o ficheiro. Proba con outro PDF.`,
        'alerts.pdfOpenError': `Non se puido abrir o PDF: {error}`,
        'alerts.imageOpenError': `Non se puido abrir a imaxe. Proba con outro ficheiro.`,
        'alerts.imageGenericError': `Non se puido abrir a imaxe.`,
        'alerts.imageSizeUnknown': `Non se puido determinar o tamaño da imaxe.`,
        'alerts.pdfLoadErrorLog': `Erro ao cargar o PDF`,
        'alerts.imageLoadErrorLog': `Non se puido cargar a imaxe seleccionada.`,
        'alerts.fileReadErrorLog': `Non se puido ler o ficheiro soltado/seleccionado.`,
        'alerts.syncInputWarn': `Non se puido sincronizar a entrada de ficheiros co arrastre.`,
        'controls.toggle.show': `Mostrar o panel de controis`,
        'controls.toggle.hide': `Agochar o panel de controis`,
        'controls.toggle.showButton': `Mostrar o panel de controis`,
        'export.notice.pngSingle': `Xerarase unha única imaxe PNG apilando as {pages} páxinas (ancho máximo {width}px e alto limitado a {height}px para que a IA lea o contido). Pode tardar uns segundos.`,
        'defaults.document': `documento`,
        'defaults.documentPdf': `documento.pdf`,
      },
      eu: {
        'app.windowTitle': `PDF eta irudien anonimizatzailea — bezeroa`,
        'app.headerTitle': `PDF eta irudien anonimizatzailea`,
        'lang.label': `Hizkuntza`,
        'info.noticeButton': `Ohar garrantzitsua`,
        'drop.default': `Arrastatu PDF bat edo irudi bat edo egin klik irekitzeko`,
        'status.page': `Orria`,
        'controls.usage.title': `Erabilera`,
        'controls.usage.help': `Arratoia arrastatuz marraztu laukizuzenak izenaren gainean. Egin eskuineko klik laukizuzen bera PDFko orri guztietan aplikatzeko. Klik bikoitzak azken laukizuzena ezabatzen du.`,
        'controls.rect.title': `Laukizuzenaren marrazketa`,
        'controls.rect.stroke': `Ertzaren lodiera:`,
        'controls.rect.opacity': `Estalduraren opakutasuna:`,
        'controls.rect.colorTitle': `Maskararen kolorea`,
        'controls.rect.color.black': `Beltza`,
        'controls.rect.color.white': `Zuria`,
        'controls.rect.color.gray': `Grisa`,
        'controls.clearButton': `Garbitu orri honetako laukizuzenak`,
        'naming.legend': `Esportatutako fitxategiaren izena`,
        'naming.option.derived': `Izen bera + _anonim`,
        'naming.option.fixed': `anonim.pdf`,
        'export.button.default': `Esportatu anonimizatuta`,
        'export.button.withTarget': `Esportatu {target}`,
        'export.mode.pdf': `PDF anonimizatua`,
        'export.mode.zip': `PNG bat orri bakoitzeko duen ZIPa`,
        'export.mode.pngSingle': `PNG orri guztiekin`,
        'export.mode.pngImage': `PNG irudi anonimizatua`,
        'export.selector.label': `Esportazio-formatua`,
        'details.security.title': `Anonimizazioaren segurtasun-oharrak`,
        'details.security.item1': `Esportazioak irudiz osatutako PDFa sortzen du (rasterizatua). Jatorrizko testua desagertu egiten da: ez da hauta daitekeena ezta testu gisa ateragarria ere.`,
        'details.security.item2': `Egokia da ikasleen lanetako izen propioak ezkutatzeko, fitxategia handiagoa eta irisgarritasuna txikiagoa izatearen truke.`,
        'details.security.item3': `Erabilera erabat lokala da zure nabigatzailean.`,
        'details.credits.title': `Kredituak eta laguntza`,
        'details.credits.contact': `Zalantzak edo iradokizunak? Sakatu botoi berdea <a href="https://github.com/jjdeharo/anonim-pdf/issues" style="color:inherit; text-decoration:underline;">New issue</a> GitHuben.`,
        'details.credits.owner': `PDF eta irudien anonimizatzailea · © 2025 <a href="https://bilateria.es" style="color:inherit; text-decoration:underline;">Juan José de Haro</a> · Baliabidea: <a href="https://github.com/jjdeharo/anonim-pdf" style="color:inherit; text-decoration:underline;">github.com/jjdeharo/anonim-pdf</a>`,
        'details.credits.license': `<a href="./LICENSE.txt" style="color:inherit; text-decoration:underline;">Kodearen lizentzia: AGPL v3</a>`,
        'viewer.zoom.label': `Zooma:`,
        'viewer.zoom.fit': `Doitu zabalera`,
        'modal.close': `Itxi oharra`,
        'modal.title': `Ohar garrantzitsua`,
        'modal.body1': `<strong>Aplikazio honek PDF anonimizatua sortzen du soilik</strong>, ikasleen datu identifikatzaileak ezkutatuz, dokumentuak adimen artifizialeko tresnetan erabili ahal izateko informazio pertsonala agerian utzi gabe.`,
        'modal.body2': `Adimen artifizialak lagungarri izan daiteke analisi partzialak lortzeko, ereduak detektatzeko edo ikasleen lanen inguruko ikuspegi berriak emateko. <strong>Ez da nahastu behar bere erabilera irakasle-lanarekin</strong>: AAk ez du ebaluatzen, ez du zuzentzen eta ezin du hezkuntza-erantzukizuna bere gain hartu.`,
        'modal.body3': `<strong>Ebaluazioa, irizpide pedagogikoa eta ikasleen kalifikazioa beti irakasleen esku dago.</strong> AAk hausnarketa osatu dezake, baina inoiz ez du ordezkatuko irakaslearen profesionaltasuna eta azken erabakia.`,
        'alerts.pdfjsMissing': `Ezin izan da pdf.js kargatu. Egiaztatu konexioa edo blokeatzaileak. "pdfjsLib" erakusteko legacy build-era aldatu naiz.`,
        'alerts.pdfjsWorkerWarning': `Errorea pdf.js worker-a konfiguratzean; worker-rik gabeko modua erabiliko da.`,
        'alerts.exportError': `Errorea gertatu da dokumentua anonimizatuta esportatzean.`,
        'alerts.exportErrorLog': `Errorea esportazioan.`,
        'alerts.jsPdfMissing': `Ezin izan da jsPDF liburutegia kargatu.`,
        'alerts.jsZipMissing': `Ezin izan da JSZip liburutegia kargatu.`,
        'alerts.pngScaleNotice': `PNG bakarrak bereizmen txikiagoa izango du dokumentua luzea delako. Egiaztatu emaitza irakurgarria dela.`,
        'alerts.singlePngFail': `Ezin izan da PNG bakarra anonimizatua sortu.`,
        'alerts.imagePngFail': `Ezin izan da irudi anonimizatua sortu.`,
        'alerts.invalidFileType': `Hautatu PDF edo irudi fitxategi bat (PNG, JPG, WEBP…).`,
        'alerts.fileReadFailed': `Ezin izan da fitxategia irakurri. Saiatu beste PDF batekin.`,
        'alerts.pdfOpenError': `Ezin izan da PDFa ireki: {error}`,
        'alerts.imageOpenError': `Ezin izan da irudia ireki. Saiatu beste fitxategi batekin.`,
        'alerts.imageGenericError': `Ezin izan da irudia ireki.`,
        'alerts.imageSizeUnknown': `Ezin izan da irudiaren tamaina zehaztu.`,
        'alerts.pdfLoadErrorLog': `Errorea PDFa kargatzean`,
        'alerts.imageLoadErrorLog': `Ezin izan da hautatutako irudia kargatu.`,
        'alerts.fileReadErrorLog': `Ezin izan da arrastatutako/hautatutako fitxategia irakurri.`,
        'alerts.syncInputWarn': `Ezin izan da fitxategi-sarrera arrastaketarekin sinkronizatu.`,
        'controls.toggle.show': `Erakutsi kontrol-panela`,
        'controls.toggle.hide': `Ezkutatu kontrol-panela`,
        'controls.toggle.showButton': `Erakutsi kontrol-panela`,
        'export.notice.pngSingle': `PNG irudi bakarra sortuko da {pages} orriak pilatuz (gehienezko zabalera {width}px eta altuera {height}px, AAk edukia irakur dezan). Segundo batzuk behar izan ditzake.`,
        'defaults.document': `dokumentua`,
        'defaults.documentPdf': `dokumentua.pdf`,
      },
      en: {
        'app.windowTitle': `PDF & Image Anonymizer — client`,
        'app.headerTitle': `PDF & Image Anonymizer`,
        'lang.label': `Language`,
        'info.noticeButton': `Important notice`,
        'drop.default': `Drop a PDF or image or click to open`,
        'status.page': `Page`,
        'controls.usage.title': `Usage`,
        'controls.usage.help': `Drag with the mouse to draw rectangles over the name. Right-click to reuse the same rectangle on every PDF page. Double-click removes the last rectangle.`,
        'controls.rect.title': `Rectangle drawing`,
        'controls.rect.stroke': `Border thickness:`,
        'controls.rect.opacity': `Mask opacity:`,
        'controls.rect.colorTitle': `Mask color`,
        'controls.rect.color.black': `Black`,
        'controls.rect.color.white': `White`,
        'controls.rect.color.gray': `Gray`,
        'controls.clearButton': `Clear rectangles on this page`,
        'naming.legend': `Exported file name`,
        'naming.option.derived': `Same name + _anonim`,
        'naming.option.fixed': `anonim.pdf`,
        'export.button.default': `Export anonymized`,
        'export.button.withTarget': `Export {target}`,
        'export.mode.pdf': `Anonymized PDF`,
        'export.mode.zip': `ZIP with one PNG per page`,
        'export.mode.pngSingle': `PNG with every page`,
        'export.mode.pngImage': `Anonymized PNG image`,
        'export.selector.label': `Export format`,
        'details.security.title': `Anonymization safety notes`,
        'details.security.item1': `Exporting creates an image-based (rasterized) PDF. The original text disappears: it is no longer selectable or extractable.`,
        'details.security.item2': `Ideal for hiding pupil names in submitted work, at the cost of larger files and reduced accessibility.`,
        'details.security.item3': `Everything runs locally in your browser.`,
        'details.credits.title': `Credits & support`,
        'details.credits.contact': `Questions or suggestions? Click the green <a href="https://github.com/jjdeharo/anonim-pdf/issues" style="color:inherit; text-decoration:underline;">New issue</a> button on GitHub.`,
        'details.credits.owner': `PDF & Image Anonymizer · © 2025 <a href="https://bilateria.es" style="color:inherit; text-decoration:underline;">Juan José de Haro</a> · Resource: <a href="https://github.com/jjdeharo/anonim-pdf" style="color:inherit; text-decoration:underline;">github.com/jjdeharo/anonim-pdf</a>`,
        'details.credits.license': `<a href="./LICENSE.txt" style="color:inherit; text-decoration:underline;">Code license: AGPL v3</a>`,
        'viewer.zoom.label': `Zoom:`,
        'viewer.zoom.fit': `Fit width`,
        'modal.close': `Close notice`,
        'modal.title': `Important notice`,
        'modal.body1': `<strong>This application only produces an anonymized PDF</strong>, hiding students' identifying data so documents can be used with AI tools without exposing personal information.`,
        'modal.body2': `Artificial intelligence can help obtain partial analyses, detect patterns or add new perspectives to students' work. <strong>It must not be confused with the teacher's role</strong>: AI does not grade, does not correct and cannot assume educational responsibility.`,
        'modal.body3': `<strong>Assessment, pedagogical judgement and grading always belong to the teaching staff.</strong> AI can support reflection, but never replace professional criteria or the teacher's final decision.`,
        'alerts.pdfjsMissing': `pdf.js could not be loaded. Check your connection or blockers. Switched to the legacy build to expose "pdfjsLib".`,
        'alerts.pdfjsWorkerWarning': `Failed to configure the pdf.js worker; running in workerless mode.`,
        'alerts.exportError': `An error occurred while exporting the anonymized document.`,
        'alerts.exportErrorLog': `Error during export.`,
        'alerts.jsPdfMissing': `The jsPDF library could not be loaded.`,
        'alerts.jsZipMissing': `The JSZip library could not be loaded.`,
        'alerts.pngScaleNotice': `The single PNG will be generated at a lower resolution because of the document length. Please check that the result is readable.`,
        'alerts.singlePngFail': `The single anonymized image could not be generated.`,
        'alerts.imagePngFail': `The anonymized image could not be generated.`,
        'alerts.invalidFileType': `Select a PDF or an image file (PNG, JPG, WEBP…).`,
        'alerts.fileReadFailed': `The file could not be read. Try another PDF.`,
        'alerts.pdfOpenError': `The PDF could not be opened: {error}`,
        'alerts.imageOpenError': `The image could not be opened. Try another file.`,
        'alerts.imageGenericError': `The image could not be opened.`,
        'alerts.imageSizeUnknown': `The image dimensions could not be determined.`,
        'alerts.pdfLoadErrorLog': `Error loading PDF`,
        'alerts.imageLoadErrorLog': `Could not load the selected image.`,
        'alerts.fileReadErrorLog': `Could not read the dropped/selected file.`,
        'alerts.syncInputWarn': `Could not sync the file input with the drop action.`,
        'controls.toggle.show': `Show control panel`,
        'controls.toggle.hide': `Hide control panel`,
        'controls.toggle.showButton': `Show control panel`,
        'export.notice.pngSingle': `Generates a single PNG stacking {pages} pages (maximum width {width}px and height capped at {height}px so AI can read the content). It may take a few seconds.`,
        'defaults.document': `document`,
        'defaults.documentPdf': `document.pdf`,
      },
    };

    let currentLocale = detectInitialLocale();

    const havePdfjs = typeof window.pdfjsLib !== 'undefined';
    if (!havePdfjs) {
      alert(t('alerts.pdfjsMissing'));
      return;
    }

    const WORKER_SRC = './vendor/pdfjs/pdf.worker.v216.min.js';
    try {
      pdfjsLib.GlobalWorkerOptions.workerSrc = WORKER_SRC;
    } catch (err) {
      console.warn(t('alerts.pdfjsWorkerWarning'), err);
      pdfjsLib.disableWorker = true;
    }

    const viewerContainer = document.getElementById('viewerContainer');
    const pagesContainer = document.getElementById('pagesContainer');
    const fileDrop = document.getElementById('fileDrop');
    const fileDropText = fileDrop.querySelector('span');
    const fileInput = document.getElementById('file');
    const pageNumEl = document.getElementById('pageNum');
    const pageCountEl = document.getElementById('pageCount');
    const btnExport = document.getElementById('export');
    const btnClearRects = document.getElementById('btnClearRects');
    const exportModeEl = document.getElementById('exportMode');
    const exportNoticeEl = document.getElementById('exportNotice');
    const downloadLink = document.getElementById('dlLink');
    const opacityEl = document.getElementById('opacity');
    const strokeWEl = document.getElementById('strokeW');
    const maskColorEl = document.getElementById('maskColor');
    const namingRadios = document.querySelectorAll('input[name="namingOption"]');
    const zoomOutBtn = document.getElementById('zoomOut');
    const zoomInBtn = document.getElementById('zoomIn');
    const zoomFitBtn = document.getElementById('zoomFit');
    const zoomDisplay = document.getElementById('zoomDisplay');
    const toggleControlsBtn = document.getElementById('toggleControls');
    const showControlsBtn = document.getElementById('showControls');
    const profModal = document.getElementById('profModal');
    const closeProfModalBtn = document.getElementById('closeProfModal');
    const openProfModalBtn = document.getElementById('openProfModal');
    const languageSelect = document.getElementById('languageSelect');
    let lastFocusBeforeModal = null;

    let pdfDoc = null;
    let imageDoc = null;
    let docType = null;
    let scale = 1;
    let rectsByPage = {};
    let currentFileName = getDefaultDocumentName('.pdf');
    let namingStrategy = 'derived';
    let fitScale = 1;
    let basePageWidth = 0;
    let zoomFactor = 1;
    let resizeTimeout = null;
    const MIN_ZOOM = 0.6;
    const MAX_ZOOM = 3;
    const ZOOM_STEP = 0.2;
    const EXPORT_RENDER_SCALE = 2;
    const EXPORT_IMAGE_QUALITY = 0.92;
    const ZOOM_KEY = 'anonim-pdf-zoom';
    const CONTROLS_HIDDEN_KEY = 'anonim-pdf-controls-hidden';
    const EXPORT_MODE_KEY = 'anonim-pdf-export-mode';
    const SUPPORTED_IMAGE_REGEX = /\.(png|jpe?g|gif|bmp|webp|tiff?)$/i;
    const SINGLE_IMAGE_TARGET_WIDTH = 2048;
    const SINGLE_IMAGE_MAX_HEIGHT = 16384;
    const SINGLE_IMAGE_MAX_SCALE = 4.5;
    const SINGLE_IMAGE_MIN_SCALE = 1.6;
    const SINGLE_IMAGE_PAGE_GAP = 24;
    const SINGLE_IMAGE_CANVAS_LIMIT = 32760;
    const SINGLE_IMAGE_BACKGROUND = '#ffffff';
    let activePage = 1;
    let pageCount = 0;
    const pageViews = new Map();
    const pageStates = new Map();

    const observer = 'IntersectionObserver' in window
      ? new IntersectionObserver((entries) => {
          let nextPage = activePage;
          let maxRatio = 0;
          for (const entry of entries) {
            if (entry.isIntersecting && entry.intersectionRatio > maxRatio) {
              nextPage = Number(entry.target.dataset.page);
              maxRatio = entry.intersectionRatio;
            }
          }
          if (nextPage !== activePage && pageViews.has(nextPage)) {
            setActivePage(nextPage);
          }
        }, { root: viewerContainer, threshold: [0.2, 0.45, 0.7] })
      : null;

    applyLocale(currentLocale, { skipPersist: true, initial: true });
    setFileDropStatus(getDefaultDropText(), false);
    resetExportControls();

    const storedControlsHidden = localStorage.getItem(CONTROLS_HIDDEN_KEY) === 'true';
    setControlsHidden(storedControlsHidden);

    function persistControlsHidden(hidden) {
      localStorage.setItem(CONTROLS_HIDDEN_KEY, hidden ? 'true' : 'false');
    }

    toggleControlsBtn?.addEventListener('click', () => {
      const nextHidden = !document.body.classList.contains('controlsHidden');
      setControlsHidden(nextHidden);
      persistControlsHidden(nextHidden);
    });

    showControlsBtn?.addEventListener('click', () => {
      setControlsHidden(false);
      persistControlsHidden(false);
      toggleControlsBtn?.focus({ preventScroll: true });
    });

    openProfModalBtn?.addEventListener('click', () => openProfModal());
    closeProfModalBtn?.addEventListener('click', () => closeProfModal());
    profModal?.addEventListener('click', (event) => {
      if (event.target === profModal) {
        closeProfModal();
      }
    });
    document.addEventListener('keydown', (event) => {
      if (event.key === 'Escape' && profModal?.classList.contains('active')) {
        closeProfModal();
      }
    });

    fileDrop.addEventListener('click', () => fileInput.click());
    fileDrop.addEventListener('dragenter', (e) => {
      e.preventDefault();
      fileDrop.classList.add('dragging');
    });
    fileDrop.addEventListener('dragover', (e) => {
      e.preventDefault();
      e.dataTransfer.dropEffect = 'copy';
      fileDrop.classList.add('dragging');
    });
    fileDrop.addEventListener('dragleave', (e) => {
      const next = e.relatedTarget;
      if (!next || !fileDrop.contains(next)) {
        fileDrop.classList.remove('dragging');
      }
    });
    fileDrop.addEventListener('drop', async (e) => {
      e.preventDefault();
      fileDrop.classList.remove('dragging');
      const files = e.dataTransfer?.files;
      if (!files || !files.length) return;
      const file = files[0];
      if (!await openDocument(file)) return;
      try {
        const dt = new DataTransfer();
        dt.items.add(file);
        fileInput.files = dt.files;
      } catch (err) {
        console.warn(t('alerts.syncInputWarn'), err);
      }
    });

    fileInput.addEventListener('change', async (e) => {
      const file = e.target.files[0];
      if (!file) return;
      await openDocument(file);
      e.target.value = '';
    });

    exportModeEl.addEventListener('change', () => {
      updateExportButtonLabel();
      if (docType === 'pdf') {
        localStorage.setItem(EXPORT_MODE_KEY, exportModeEl.value);
      }
      updateExportNotice();
    });

    btnClearRects.addEventListener('click', () => {
      if (!docType) return;
      rectsByPage[activePage] = [];
      drawOverlay(activePage);
      updateClearButtonState();
    });

    maskColorEl.addEventListener('change', redrawAllOverlays);
    opacityEl.addEventListener('change', redrawAllOverlays);
    strokeWEl.addEventListener('change', redrawAllOverlays);

    const NAMING_KEY = 'anonim-pdf-naming';
    const storedNaming = (localStorage.getItem(NAMING_KEY) || '').toLowerCase();
    if (storedNaming === 'fixed' || storedNaming === 'derived') {
      namingStrategy = storedNaming;
    }
    namingRadios.forEach((radio) => {
      radio.checked = radio.value === namingStrategy;
      radio.addEventListener('change', () => {
        if (radio.checked) {
          namingStrategy = radio.value === 'fixed' ? 'fixed' : 'derived';
          localStorage.setItem(NAMING_KEY, namingStrategy);
        }
      });
    });

    languageSelect?.addEventListener('change', (event) => {
      const nextLocale = event.target.value;
      applyLocale(nextLocale);
    });

    const storedZoom = parseFloat(localStorage.getItem(ZOOM_KEY) || '');
    if (!Number.isNaN(storedZoom)) {
      zoomFactor = clamp(storedZoom, MIN_ZOOM, MAX_ZOOM);
    }
    setZoomControlsEnabled(false);
    updateZoomDisplay();

    zoomInBtn.addEventListener('click', () => {
      setZoomFactor(zoomFactor + ZOOM_STEP).catch((err) => console.error(err));
    });
    zoomOutBtn.addEventListener('click', () => {
      setZoomFactor(zoomFactor - ZOOM_STEP).catch((err) => console.error(err));
    });
    zoomFitBtn.addEventListener('click', () => {
      setZoomFactor(1).catch((err) => console.error(err));
    });

    btnExport.addEventListener('click', async () => {
      if (btnExport.disabled || !docType) return;
      try {
        if (docType === 'pdf') {
          const mode = exportModeEl.value;
          if (mode === 'zip') {
            await exportPdfAsZip();
          } else if (mode === 'png-single') {
            await exportPdfAsSingleImage();
          } else {
            await exportPdfAsPdf();
          }
        } else if (docType === 'image') {
          await exportImageAsPng();
        }
      } catch (err) {
        console.error(t('alerts.exportErrorLog'), err);
        alert(t('alerts.exportError'));
      }
    });

    function getMaskSettings() {
      const mask = maskColorEl.value || '#000';
      const alpha = Math.max(0.1, Math.min(1, Number(opacityEl.value) || 1));
      return { mask, alpha };
    }

    function getRectScaleForExport(targetScale) {
      return scale > 0 ? targetScale / scale : targetScale;
    }

    async function exportPdfAsPdf() {
      if (!pdfDoc) return;
      const jspdfNs = window.jspdf;
      if (!jspdfNs || typeof jspdfNs.jsPDF !== 'function') {
        alert(t('alerts.jsPdfMissing'));
        return;
      }
      const { jsPDF } = jspdfNs;
      const pdfOut = new jsPDF({ unit: 'pt', compress: true });
      pdfOut.deletePage(1);

      const { mask, alpha } = getMaskSettings();
      const totalPages = pdfDoc.numPages;
      for (let p = 1; p <= totalPages; p++) {
        const page = await pdfDoc.getPage(p);
        const baseViewport = page.getViewport({ scale: 1 });
        const exportViewport = page.getViewport({ scale: EXPORT_RENDER_SCALE });

        const pageCanvas = document.createElement('canvas');
        pageCanvas.width = exportViewport.width;
        pageCanvas.height = exportViewport.height;
        const pctx = pageCanvas.getContext('2d');
        await page.render({ canvasContext: pctx, viewport: exportViewport }).promise;

        const rects = rectsByPage[p] || [];
        const rectScale = getRectScaleForExport(EXPORT_RENDER_SCALE);
        paintMaskRects(pctx, rects, mask, alpha, rectScale);

        pdfOut.addPage([baseViewport.width, baseViewport.height]);
        pdfOut.setPage(pdfOut.getNumberOfPages());

        const img = pageCanvas.toDataURL('image/jpeg', EXPORT_IMAGE_QUALITY);
        pdfOut.addImage(img, 'JPEG', 0, 0, baseViewport.width, baseViewport.height, undefined, 'FAST');
      }

      const blob = pdfOut.output('blob');
      triggerDownload(blob, buildAnonName(currentFileName, '.pdf'));
    }

    async function exportPdfAsZip() {
      if (!pdfDoc) return;
      const JSZipCtor = window.JSZip;
      if (typeof JSZipCtor !== 'function') {
        alert(t('alerts.jsZipMissing'));
        return;
      }
      const zip = new JSZipCtor();
      const { mask, alpha } = getMaskSettings();
      const totalPages = pdfDoc.numPages;
      const padding = String(totalPages).length;

      for (let p = 1; p <= totalPages; p++) {
        const page = await pdfDoc.getPage(p);
        const exportViewport = page.getViewport({ scale: EXPORT_RENDER_SCALE });
        const pageCanvas = document.createElement('canvas');
        pageCanvas.width = exportViewport.width;
        pageCanvas.height = exportViewport.height;
        const ctx = pageCanvas.getContext('2d');
        await page.render({ canvasContext: ctx, viewport: exportViewport }).promise;

        const rects = rectsByPage[p] || [];
        const rectScale = getRectScaleForExport(EXPORT_RENDER_SCALE);
        paintMaskRects(ctx, rects, mask, alpha, rectScale);

        const dataUrl = pageCanvas.toDataURL('image/png');
        const base64 = dataUrl.split(',')[1] || '';
        const fileName = `pagina-${String(p).padStart(padding, '0')}.png`;
        zip.file(fileName, base64, { base64: true });
      }

      const blob = await zip.generateAsync({ type: 'blob' });
      triggerDownload(blob, buildAnonName(currentFileName, '.zip'));
    }

    async function exportPdfAsSingleImage() {
      if (!pdfDoc) return;
      const totalPages = pdfDoc.numPages;
      if (totalPages === 0) return;
      const { mask, alpha } = getMaskSettings();

      const entries = [];
      let maxWidth = 0;
      let totalHeight = 0;
      for (let p = 1; p <= totalPages; p++) {
        const page = await pdfDoc.getPage(p);
        const viewport = page.getViewport({ scale: 1 });
        entries.push({ pageNumber: p, page, width: viewport.width, height: viewport.height });
        maxWidth = Math.max(maxWidth, viewport.width);
        totalHeight += viewport.height;
      }

      const gapTotal = SINGLE_IMAGE_PAGE_GAP * Math.max(0, totalPages - 1);
      const heightScale = (SINGLE_IMAGE_MAX_HEIGHT - gapTotal) / totalHeight;
      const heightLimitScale = (SINGLE_IMAGE_CANVAS_LIMIT - gapTotal) / totalHeight;
      const widthScale = SINGLE_IMAGE_TARGET_WIDTH / maxWidth;
      const widthLimitScale = SINGLE_IMAGE_CANVAS_LIMIT / maxWidth;
      const scales = [widthScale, SINGLE_IMAGE_MAX_SCALE, heightScale, heightLimitScale, widthLimitScale]
        .filter((value) => Number.isFinite(value) && value > 0);
      let scaleFactor = scales.length ? Math.min(...scales) : 1;
      if (!Number.isFinite(scaleFactor) || scaleFactor <= 0) {
        scaleFactor = 1;
      }
      const requestedMin = SINGLE_IMAGE_MIN_SCALE;
      let minScaleNotice = false;
      if (scaleFactor < requestedMin) {
        minScaleNotice = true;
      }

      let exportHeight = Math.floor(totalHeight * scaleFactor) + gapTotal;
      if (exportHeight > SINGLE_IMAGE_CANVAS_LIMIT) {
        const adjustedScale = (SINGLE_IMAGE_CANVAS_LIMIT - gapTotal) / totalHeight;
        if (Number.isFinite(adjustedScale) && adjustedScale > 0) {
          scaleFactor = adjustedScale;
          exportHeight = Math.floor(totalHeight * scaleFactor) + gapTotal;
        } else {
          exportHeight = SINGLE_IMAGE_CANVAS_LIMIT;
        }
      }

      if (minScaleNotice) {
        alert(t('alerts.pngScaleNotice'));
      }

      const canvas = document.createElement('canvas');
      const exportWidth = Math.max(1, Math.floor(maxWidth * scaleFactor));
      canvas.width = Math.max(1, Math.min(exportWidth, SINGLE_IMAGE_CANVAS_LIMIT));
      canvas.height = Math.max(1, Math.min(exportHeight, SINGLE_IMAGE_CANVAS_LIMIT));
      const ctx = canvas.getContext('2d');
      ctx.fillStyle = SINGLE_IMAGE_BACKGROUND;
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      let offsetY = 0;
      const rectScale = getRectScaleForExport(scaleFactor);
      for (let i = 0; i < entries.length; i++) {
        const { page, pageNumber, width, height } = entries[i];
        const viewport = page.getViewport({ scale: scaleFactor });
        const renderCanvas = document.createElement('canvas');
        renderCanvas.width = Math.max(1, Math.round(viewport.width));
        renderCanvas.height = Math.max(1, Math.round(viewport.height));
        const rctx = renderCanvas.getContext('2d');
        await page.render({ canvasContext: rctx, viewport }).promise;

        const rects = rectsByPage[pageNumber] || [];
        paintMaskRects(rctx, rects, mask, alpha, rectScale);

        ctx.drawImage(renderCanvas, 0, offsetY);
        offsetY += renderCanvas.height;
        if (i < entries.length - 1) {
          offsetY += SINGLE_IMAGE_PAGE_GAP;
        }
        page.cleanup?.();
        entries[i].page = null;
      }

      const blob = await canvasToBlob(canvas, 'image/png');
      if (!blob) {
        alert(t('alerts.singlePngFail'));
        return;
      }
      triggerDownload(blob, buildAnonName(currentFileName, '.png'));
    }

    async function exportImageAsPng() {
      if (!imageDoc) return;
      const { mask, alpha } = getMaskSettings();
      const canvas = document.createElement('canvas');
      canvas.width = imageDoc.width;
      canvas.height = imageDoc.height;
      const ctx = canvas.getContext('2d');
      ctx.drawImage(imageDoc.image, 0, 0, canvas.width, canvas.height);

      const rects = rectsByPage[1] || [];
      const rectScale = getRectScaleForExport(1);
      paintMaskRects(ctx, rects, mask, alpha, rectScale);

      const blob = await canvasToBlob(canvas, 'image/png');
      if (!blob) {
        alert(t('alerts.imagePngFail'));
        return;
      }
      triggerDownload(blob, buildAnonName(currentFileName, '.png'));
    }

    function canvasToBlob(canvas, type, quality) {
      return new Promise((resolve) => {
        canvas.toBlob(resolve, type, quality);
      });
    }

    function paintMaskRects(ctx, rects, color, alpha, rectScale) {
      if (!ctx || !Array.isArray(rects) || rects.length === 0) return;
      const factor = Number.isFinite(rectScale) && rectScale > 0 ? rectScale : 1;
      ctx.save();
      ctx.fillStyle = color;
      for (const rect of rects) {
        ctx.globalAlpha = alpha;
        ctx.fillRect(rect.x * factor, rect.y * factor, rect.w * factor, rect.h * factor);
      }
      ctx.restore();
    }

    function triggerDownload(blob, fileName) {
      if (!blob) return;
      const url = URL.createObjectURL(blob);
      downloadLink.href = url;
      downloadLink.download = fileName;
      downloadLink.click();
      downloadLink.style.display = 'none';
      setTimeout(() => URL.revokeObjectURL(url), 10_000);
    }

    function openProfModal() {
      if (!profModal) return;
      lastFocusBeforeModal = document.activeElement instanceof HTMLElement ? document.activeElement : null;
      profModal.classList.add('active');
      document.body.style.overflow = 'hidden';
      closeProfModalBtn?.focus({ preventScroll: true });
    }

    function closeProfModal() {
      if (!profModal) return;
      profModal.classList.remove('active');
      document.body.style.overflow = '';
      lastFocusBeforeModal?.focus?.({ preventScroll: true });
    }

    function setControlsHidden(hidden) {
      document.body.classList.toggle('controlsHidden', hidden);
      const showLabel = t('controls.toggle.show');
      const hideLabel = t('controls.toggle.hide');
      const showButtonLabel = t('controls.toggle.showButton');
      if (toggleControlsBtn) {
        const label = hidden ? showLabel : hideLabel;
        toggleControlsBtn.setAttribute('aria-pressed', hidden ? 'true' : 'false');
        toggleControlsBtn.setAttribute('aria-label', label);
        toggleControlsBtn.setAttribute('title', label);
      }
      if (showControlsBtn) {
        showControlsBtn.setAttribute('aria-pressed', hidden ? 'true' : 'false');
        showControlsBtn.setAttribute('aria-label', showButtonLabel);
        showControlsBtn.setAttribute('title', showButtonLabel);
      }
    }

    function resetExportControls() {
      if (!exportModeEl) return;
      exportModeEl.innerHTML = '';
      exportModeEl.disabled = true;
      btnExport.disabled = true;
      btnExport.textContent = t('export.button.default');
      exportModeEl.value = '';
      exportModeEl.hidden = true;
      exportModeEl.style.display = 'none';
      exportModeEl.dataset.singleKey = '';
      clearExportNotice();
    }

    function setFileDropStatus(label, loaded) {
      fileDropText.textContent = label;
      if (loaded) {
        fileDrop.classList.add('hasFile');
      } else {
        fileDrop.classList.remove('hasFile');
      }
    }

    function configureExportForDoc(type) {
      if (!exportModeEl) return;
      exportModeEl.innerHTML = '';
      let defaultValue = '';
      let optionList = [];
      if (type === 'pdf') {
        optionList = [
          { value: 'pdf', key: 'export.mode.pdf' },
          { value: 'zip', key: 'export.mode.zip' }
        ];
        if (pageCount > 1) {
          optionList.push({ value: 'png-single', key: 'export.mode.pngSingle' });
        }
        const stored = localStorage.getItem(EXPORT_MODE_KEY);
        defaultValue = optionList.some((opt) => opt.value === stored) ? stored : 'pdf';
      } else {
        optionList = [{ value: 'png', key: 'export.mode.pngImage' }];
        defaultValue = 'png';
      }
      for (const opt of optionList) {
        const optionEl = document.createElement('option');
        optionEl.value = opt.value;
        optionEl.dataset.i18nKey = opt.key;
        optionEl.textContent = t(opt.key);
        exportModeEl.appendChild(optionEl);
      }
      const hasMultipleOptions = optionList.length > 1;
      btnExport.disabled = false;
      exportModeEl.value = defaultValue;
      exportModeEl.dataset.singleKey = hasMultipleOptions ? '' : (optionList[0]?.key || '');
      const showSelect = type === 'pdf' && hasMultipleOptions;
      exportModeEl.disabled = !showSelect;
      exportModeEl.hidden = !showSelect;
      exportModeEl.style.display = showSelect ? 'inline-block' : 'none';
      refreshExportModeLabels();
      updateExportButtonLabel();
      if (type !== 'pdf') {
        localStorage.removeItem(EXPORT_MODE_KEY);
      }
      updateExportNotice();
    }

    function updateExportButtonLabel() {
      let labelKey = '';
      if (exportModeEl.hidden || exportModeEl.options.length === 1) {
        labelKey = exportModeEl.dataset.singleKey || exportModeEl.options[0]?.dataset.i18nKey || '';
      } else {
        const selected = exportModeEl.options[exportModeEl.selectedIndex];
        labelKey = selected?.dataset.i18nKey || '';
      }
      const labelText = labelKey ? t(labelKey) : '';
      btnExport.textContent = labelText ? t('export.button.withTarget', { target: labelText }) : t('export.button.default');
    }

    function updateExportNotice(forceHide = false) {
      if (!exportNoticeEl) return;
      if (forceHide || !docType) {
        clearExportNotice();
        return;
      }
      if (docType === 'pdf' && pageCount > 1 && exportModeEl.value === 'png-single') {
        const widthText = formatNumber(SINGLE_IMAGE_TARGET_WIDTH);
        const heightText = formatNumber(SINGLE_IMAGE_MAX_HEIGHT);
        exportNoticeEl.textContent = t('export.notice.pngSingle', { pages: pageCount, width: widthText, height: heightText });
        exportNoticeEl.style.display = 'block';
      } else {
        clearExportNotice();
      }
    }

    function clearExportNotice() {
      if (!exportNoticeEl) return;
      exportNoticeEl.textContent = '';
      exportNoticeEl.style.display = 'none';
    }

    function resetViewerState() {
      rectsByPage = {};
      pageViews.clear();
      pageStates.clear();
      observer?.disconnect();
      pagesContainer.innerHTML = '';
      activePage = 1;
      pageCount = 0;
      docType = null;
      pageNumEl.textContent = '-';
      pageCountEl.textContent = '-';
      btnClearRects.disabled = true;
      resetExportControls();
      setZoomControlsEnabled(false);
      setFileDropStatus(getDefaultDropText(), false);
    }

    async function openDocument(file) {
      if (!file) return false;
      const name = (file && file.name) ? file.name : getDefaultDocumentBase();
      const lowerName = name.toLowerCase();
      const type = (file.type || '').toLowerCase();
      const isPdf = type === 'application/pdf' || lowerName.endsWith('.pdf');
      const isImage = type.startsWith('image/') || SUPPORTED_IMAGE_REGEX.test(lowerName);

      if (!isPdf && !isImage) {
        alert(t('alerts.invalidFileType'));
        setFileDropStatus(getDefaultDropText(), false);
        return false;
      }

      if (isPdf) {
        let arrayBuf;
        try {
          arrayBuf = await file.arrayBuffer();
        } catch (err) {
          console.error(t('alerts.fileReadErrorLog'), err);
          alert(t('alerts.fileReadFailed'));
          setFileDropStatus(getDefaultDropText(), false);
          return false;
        }
        const loaded = await loadPdfFromArrayBuffer(arrayBuf, name);
        setFileDropStatus(loaded ? name : getDefaultDropText(), loaded);
        return loaded;
      }

      const loaded = await loadImageDocument(file);
      setFileDropStatus(loaded ? name : getDefaultDropText(), loaded);
      return loaded;
    }

    async function loadPdfFromArrayBuffer(arrayBuf, fileName = getDefaultDocumentName('.pdf')) {
      const targetName = forceExtension(sanitizeFileName(fileName), '.pdf');
      const loadingTask = pdfjsLib.getDocument({
        data: arrayBuf,
        cMapUrl: './vendor/pdfjs/cmaps/',
        cMapPacked: true,
        standardFontDataUrl: './vendor/pdfjs/standard_fonts/'
      });
      try {
        pdfDoc = await loadingTask.promise;
      } catch (err) {
        console.error(t('alerts.pdfLoadErrorLog'), err);
        const message = err && err.message ? err.message : String(err);
        alert(t('alerts.pdfOpenError', { error: message }));
        return false;
      }
      resetViewerState();

      currentFileName = targetName;

      docType = 'pdf';
      imageDoc = null;

      const firstPage = await pdfDoc.getPage(1);
      const baseViewport = firstPage.getViewport({ scale: 1 });
      basePageWidth = baseViewport.width;
      fitScale = computeScaleForWidth(basePageWidth);
      scale = fitScale * zoomFactor;

      pageCount = pdfDoc.numPages;

      await renderPage(1, firstPage);
      for (let p = 2; p <= pdfDoc.numPages; p++) {
        await renderPage(p);
      }

      pageCountEl.textContent = pdfDoc.numPages;
      setActivePage(1);
      updateClearButtonState();
      configureExportForDoc('pdf');
      setZoomControlsEnabled(true);
      updateZoomDisplay();
      return true;
    }

    async function loadImageDocument(file) {
      const fallbackExt = guessImageExtension(file);
      let objectUrl = '';
      let image;
      try {
        objectUrl = URL.createObjectURL(file);
        image = await loadImageElement(objectUrl);
      } catch (err) {
        console.error(t('alerts.imageLoadErrorLog'), err);
        alert(t('alerts.imageOpenError'));
        if (objectUrl) URL.revokeObjectURL(objectUrl);
        return false;
      }
      if (objectUrl) {
        URL.revokeObjectURL(objectUrl);
      }
      if (!image) {
        alert(t('alerts.imageGenericError'));
        return false;
      }
      const width = image.naturalWidth || image.width;
      const height = image.naturalHeight || image.height;
      if (!width || !height) {
        alert(t('alerts.imageSizeUnknown'));
        return false;
      }

      resetViewerState();

      currentFileName = ensureExtension(sanitizeFileName(file.name), fallbackExt);

      docType = 'image';
      pdfDoc = null;
      imageDoc = { image, width, height };
      basePageWidth = width;
      fitScale = computeScaleForWidth(basePageWidth);
      scale = fitScale * zoomFactor;
      pageCount = 1;

      await renderPage(1, imageDoc);
      pageCountEl.textContent = '1';
      setActivePage(1);
      updateClearButtonState();
      configureExportForDoc('image');
      setZoomControlsEnabled(true);
      updateZoomDisplay();
      return true;
    }

    async function renderPage(pageNumber, pageInstance) {
      if (!docType) return;
      let view = pageViews.get(pageNumber);
      if (!view) {
        view = createPageView(pageNumber);
      }
      const { canvas, overlay, img, ctx, wrapper } = view;

      if (docType === 'pdf') {
        const page = pageInstance || await pdfDoc.getPage(pageNumber);
        const viewport = page.getViewport({ scale });
        const width = viewport.width;
        const height = viewport.height;
        canvas.width = width; canvas.height = height;
        overlay.width = width; overlay.height = height;
        img.width = width; img.height = height;
        img.style.width = overlay.style.width = width + 'px';
        img.style.height = overlay.style.height = height + 'px';
        wrapper.style.width = width + 'px';
        wrapper.style.height = height + 'px';
        await page.render({ canvasContext: ctx, viewport }).promise;
      } else if (docType === 'image' && imageDoc) {
        const width = imageDoc.width * scale;
        const height = imageDoc.height * scale;
        const canvasWidth = Math.max(1, Math.round(width));
        const canvasHeight = Math.max(1, Math.round(height));
        canvas.width = canvasWidth;
        canvas.height = canvasHeight;
        overlay.width = canvasWidth;
        overlay.height = canvasHeight;
        img.width = canvasWidth;
        img.height = canvasHeight;
        const displayWidth = canvasWidth + 'px';
        const displayHeight = canvasHeight + 'px';
        img.style.width = overlay.style.width = displayWidth;
        img.style.height = overlay.style.height = displayHeight;
        wrapper.style.width = displayWidth;
        wrapper.style.height = displayHeight;
        ctx.clearRect(0, 0, canvasWidth, canvasHeight);
        ctx.drawImage(imageDoc.image, 0, 0, canvasWidth, canvasHeight);
      }

      img.src = canvas.toDataURL('image/png');
      drawOverlay(pageNumber);
    }

    function createPageView(pageNumber) {
      const wrapper = document.createElement('div');
      wrapper.className = 'pageView';
      wrapper.dataset.page = String(pageNumber);

      const canvas = document.createElement('canvas');
      canvas.className = 'pdfPageCanvas';

      const img = document.createElement('img');
      img.className = 'pdfPageImage';
      img.draggable = false;

      const overlay = document.createElement('canvas');
      overlay.className = 'pdfOverlay';

      wrapper.append(img, overlay, canvas);
      pagesContainer.appendChild(wrapper);
      observer?.observe(wrapper);

      const view = {
        wrapper,
        canvas,
        img,
        overlay,
        ctx: canvas.getContext('2d'),
        octx: overlay.getContext('2d')
      };

      setupOverlayInteractions(pageNumber, view);
      pageViews.set(pageNumber, view);
      return view;
    }

    function setupOverlayInteractions(pageNumber, view) {
      const { overlay } = view;
      overlay.addEventListener('mousedown', (e) => {
        if (e.button !== 0 && e.button !== 2) return;
        e.preventDefault();
        const state = getPageState(pageNumber);
        const { x, y } = getMousePos(e, overlay);
        state.drawing = true;
        state.startX = x;
        state.startY = y;
        state.previewRect = null;
        state.button = e.button;
        state.applyAll = docType === 'pdf' && pageCount > 1 && e.button === 2;
        setActivePage(pageNumber);
      });

      overlay.addEventListener('mousemove', (e) => {
        const state = getPageState(pageNumber);
        if (!state.drawing) return;
        const { x, y } = getMousePos(e, overlay);
        state.previewRect = normalizeRect(state.startX, state.startY, x, y);
        drawOverlay(pageNumber);
      });

      const endDrawing = () => {
      const state = getPageState(pageNumber);
      if (!state.drawing) return;
      state.drawing = false;
      if (!rectsByPage[pageNumber]) rectsByPage[pageNumber] = [];
      const rect = state.previewRect;
      if (rect && rect.w > 4 && rect.h > 4) {
        rectsByPage[pageNumber].push({ ...rect });
        const applyAll = docType === 'pdf' && pageCount > 1 && state.applyAll;
        if (applyAll) {
          applyRectToAllPages(rect, pageNumber);
        }
      }
      state.previewRect = null;
      state.applyAll = false;
      state.button = 0;
      drawOverlay(pageNumber);
      updateClearButtonState();
    };

      overlay.addEventListener('mouseup', endDrawing);
      overlay.addEventListener('mouseleave', endDrawing);
      overlay.addEventListener('contextmenu', (e) => {
        e.preventDefault();
      });

      overlay.addEventListener('dblclick', () => {
        const list = rectsByPage[pageNumber] || [];
        list.pop();
        rectsByPage[pageNumber] = list;
        drawOverlay(pageNumber);
        updateClearButtonState();
      });
    }

    function getPageState(pageNumber) {
      if (!pageStates.has(pageNumber)) {
        pageStates.set(pageNumber, {
          drawing: false,
          startX: 0,
          startY: 0,
          previewRect: null,
          applyAll: false,
          button: 0
        });
      }
      return pageStates.get(pageNumber);
    }

    function drawOverlay(pageNumber) {
      const view = pageViews.get(pageNumber);
      if (!view) return;
      const { overlay, octx } = view;
      octx.clearRect(0, 0, overlay.width, overlay.height);
      const mask = maskColorEl.value || '#000';
      const alpha = Math.max(0.1, Math.min(1, Number(opacityEl.value) || 1));
      const strokeW = Number(strokeWEl.value) || 2;
      const rects = rectsByPage[pageNumber] || [];
      const preview = pageStates.get(pageNumber)?.previewRect || null;

      octx.save();
      for (const rect of rects) paintRect(octx, rect, mask, alpha, strokeW);
      if (preview) paintRect(octx, preview, mask, alpha, strokeW);
      octx.restore();
    }

    function paintRect(ctx, rect, mask, alpha, strokeW) {
      ctx.globalAlpha = alpha;
      ctx.fillStyle = mask;
      ctx.fillRect(rect.x, rect.y, rect.w, rect.h);
      ctx.globalAlpha = 1;
      ctx.lineWidth = strokeW;
      ctx.strokeStyle = '#000';
      ctx.strokeRect(rect.x, rect.y, rect.w, rect.h);
    }

    function redrawAllOverlays() {
      for (const pageNumber of pageViews.keys()) {
        drawOverlay(pageNumber);
      }
    }

    function updateZoomDisplay() {
      if (zoomDisplay) {
        zoomDisplay.textContent = `${Math.round(zoomFactor * 100)}%`;
      }
      const canZoom = !!docType;
      zoomInBtn.disabled = !canZoom || zoomFactor >= (MAX_ZOOM - 0.01);
      zoomOutBtn.disabled = !canZoom || zoomFactor <= (MIN_ZOOM + 0.01);
      zoomFitBtn.disabled = !canZoom;
    }

    function setZoomControlsEnabled(enabled) {
      if (!enabled) {
        zoomInBtn.disabled = true;
        zoomOutBtn.disabled = true;
        zoomFitBtn.disabled = true;
      } else {
        updateZoomDisplay();
      }
    }

    async function setZoomFactor(newFactor) {
      const clamped = clamp(newFactor, MIN_ZOOM, MAX_ZOOM);
      if (Math.abs(clamped - zoomFactor) < 0.001) {
        updateZoomDisplay();
        return;
      }
      zoomFactor = clamped;
      localStorage.setItem(ZOOM_KEY, zoomFactor.toFixed(2));
      updateZoomDisplay();
      if (!docType) return;
      await applyScale();
    }

    async function applyScale() {
      const newScale = fitScale * zoomFactor;
      const factor = newScale / scale;
      scale = newScale;
      if (Math.abs(factor - 1) > 0.001) {
        rescaleRects(factor);
      }
      for (const state of pageStates.values()) {
        state.drawing = false;
        state.previewRect = null;
      }
      await rerenderAllPages();
      redrawAllOverlays();
    }

    function rescaleRects(factor) {
      for (const key of Object.keys(rectsByPage)) {
        const arr = rectsByPage[key];
        if (!Array.isArray(arr)) continue;
        rectsByPage[key] = arr.map((rect) => ({
          x: rect.x * factor,
          y: rect.y * factor,
          w: rect.w * factor,
          h: rect.h * factor,
        }));
      }
    }

    function applyRectToAllPages(rect, sourcePage) {
      if (docType !== 'pdf' || pageCount <= 1) return;
      for (let p = 1; p <= pageCount; p++) {
        if (p === sourcePage) continue;
        if (!rectsByPage[p]) rectsByPage[p] = [];
        rectsByPage[p].push({ ...rect });
        if (pageViews.has(p)) {
          drawOverlay(p);
        }
      }
    }

    async function rerenderAllPages() {
      if (!docType) return;
      for (let pageNum = 1; pageNum <= pageCount; pageNum++) {
        await renderPage(pageNum);
      }
    }

    function setActivePage(pageNumber) {
      if (!pageViews.has(pageNumber)) return;
      activePage = pageNumber;
      pageNumEl.textContent = pageNumber;
      for (const [num, view] of pageViews.entries()) {
        view.wrapper.classList.toggle('active', num === pageNumber);
      }
      updateClearButtonState();
    }

    function updateClearButtonState() {
      if (!docType) {
        btnClearRects.disabled = true;
        return;
      }
      const rects = rectsByPage[activePage] || [];
      btnClearRects.disabled = rects.length === 0;
    }

    function computeScaleForWidth(pageWidth) {
      const containerWidth = viewerContainer.clientWidth || viewerContainer.getBoundingClientRect().width;
      if (!containerWidth) return 1;
      const available = Math.max(containerWidth - 24, 200);
      const fitScale = available / pageWidth;
      if (!Number.isFinite(fitScale) || fitScale <= 0) return 1;
      return Math.min(1.3, fitScale);
    }

    function clamp(value, min, max) {
      return Math.min(max, Math.max(min, value));
    }

    window.addEventListener('resize', () => {
      if (!docType || !basePageWidth) return;
      clearTimeout(resizeTimeout);
      resizeTimeout = setTimeout(async () => {
        const newFit = computeScaleForWidth(basePageWidth);
        if (!Number.isFinite(newFit) || newFit <= 0) return;
        const prevScale = scale;
        fitScale = newFit;
        const newScale = fitScale * zoomFactor;
        const factor = newScale / prevScale;
        scale = newScale;
        if (Math.abs(factor - 1) > 0.001) {
          rescaleRects(factor);
        }
        await rerenderAllPages();
        redrawAllOverlays();
        updateZoomDisplay();
      }, 180);
    });

    function normalizeExtension(ext, defaultExt = '') {
      if (!ext) return defaultExt;
      return ext.startsWith('.') ? ext : `.${ext}`;
    }

    function sanitizeFileName(name) {
      if (!name || typeof name !== 'string') return getDefaultDocumentBase();
      const invalid = /[\\/:*?"<>|]+/g;
      const cleaned = name.replace(invalid, '_').trim();
      return cleaned || getDefaultDocumentBase();
    }

    function ensureExtension(name, ext) {
      const normalizedExt = normalizeExtension(ext, '');
      if (!normalizedExt) return name;
      if (/\.[^.]+$/.test(name)) {
        return name;
      }
      return `${name}${normalizedExt}`;
    }

    function forceExtension(name, ext) {
      const normalizedExt = normalizeExtension(ext, '');
      if (!normalizedExt) return name;
      const base = name.replace(/\.[^.]+$/, '');
      return `${base}${normalizedExt}`;
    }

    function buildAnonName(original, fallbackExt = '.pdf') {
      const normalizedExt = normalizeExtension(fallbackExt, '.pdf');
      if (namingStrategy === 'fixed') {
        return `anonim${normalizedExt}`;
      }
      const safeName = sanitizeFileName(original);
      const match = safeName.match(/(\.[^.]+)$/);
      const base = match ? safeName.slice(0, -match[0].length) : safeName;
      const ext = normalizedExt || (match ? match[0] : '');
      return `${base}_anonim${ext}`;
    }

    function t(key, vars = {}, localeOverride) {
      const locale = normalizeLocale(localeOverride) || currentLocale || FALLBACK_LOCALE;
      const dict = TRANSLATIONS[locale] || TRANSLATIONS[FALLBACK_LOCALE] || {};
      const fallbackDict = TRANSLATIONS[FALLBACK_LOCALE] || {};
      let template = dict[key];
      if (template === undefined) {
        template = fallbackDict[key];
      }
      if (template === undefined) {
        return '';
      }
      const text = String(template);
      return text.replace(/\{(\w+)\}/g, (_, name) => (name in vars ? String(vars[name]) : ''));
    }

    function normalizeLocale(locale) {
      if (!locale) return null;
      const lower = String(locale).toLowerCase();
      if (SUPPORTED_LOCALES.includes(lower)) return lower;
      const base = lower.split('-')[0];
      return SUPPORTED_LOCALES.includes(base) ? base : null;
    }

    function detectInitialLocale() {
      try {
        const stored = normalizeLocale(localStorage.getItem(LANG_STORAGE_KEY));
        if (stored) return stored;
      } catch (err) {
        // storage might be unavailable
      }
      const fromNavigator = Array.isArray(navigator.languages)
        ? navigator.languages.map(normalizeLocale).find(Boolean)
        : normalizeLocale(navigator.language);
      return fromNavigator || FALLBACK_LOCALE;
    }

    function applyTranslations(root = document) {
      const elements = root.querySelectorAll('*');
      for (const el of elements) {
        const dataset = el.dataset;
        if (!dataset) continue;
        const needsTranslation = Object.keys(dataset).some((key) => key.startsWith('i18n'));
        if (needsTranslation) {
          translateElement(el);
        }
      }
    }

    function translateElement(el) {
      if (!el || !el.dataset) return;
      const { dataset } = el;
      if (dataset.i18n) {
        const value = t(dataset.i18n);
        if (dataset.i18nType === 'html') {
          el.innerHTML = value;
        } else {
          el.textContent = value;
        }
      }
      for (const [dataKey, valueKey] of Object.entries(dataset)) {
        if (!dataKey.startsWith('i18nAttr')) continue;
        const rawName = dataKey.slice('i18nAttr'.length);
        if (!rawName) continue;
        const attrName = toAttrName(rawName);
        if (!attrName) continue;
        el.setAttribute(attrName, t(valueKey));
      }
    }

    function toAttrName(rawName) {
      if (!rawName) return '';
      return rawName.replace(/([A-Z])/g, (match, _grp, offset) => (offset ? '-' : '') + match.toLowerCase());
    }

    function formatNumber(value) {
      const code = LOCALE_INTL[currentLocale] || LOCALE_INTL[FALLBACK_LOCALE] || 'en';
      return new Intl.NumberFormat(code).format(value);
    }

    function refreshExportModeLabels() {
      if (!exportModeEl) return;
      const options = Array.from(exportModeEl.options);
      for (const option of options) {
        const key = option.dataset.i18nKey;
        if (key) {
          option.textContent = t(key);
        }
      }
    }

    function applyLocale(locale, { skipPersist = false, initial = false } = {}) {
      const normalized = normalizeLocale(locale) || FALLBACK_LOCALE;
      if (!skipPersist) {
        try {
          localStorage.setItem(LANG_STORAGE_KEY, normalized);
        } catch (err) {
          // storage might be unavailable; ignore
        }
      }
      currentLocale = normalized;
      document.documentElement.lang = normalized;
      document.title = t('app.windowTitle');
      if (languageSelect && languageSelect.value !== normalized) {
        languageSelect.value = normalized;
      }
      applyTranslations();
      refreshExportModeLabels();
      updateExportButtonLabel();
      updateExportNotice();
      setControlsHidden(document.body.classList.contains('controlsHidden'));
      if (!docType && !fileDrop.classList.contains('hasFile')) {
        setFileDropStatus(getDefaultDropText(), false);
      }
    }

    function getDefaultDropText() {
      return t('drop.default');
    }

    function getDefaultDocumentBase() {
      const base = t('defaults.document');
      return base || 'documento';
    }

    function getDefaultDocumentName(ext = '.pdf') {
      return ensureExtension(getDefaultDocumentBase(), ext);
    }

    function guessImageExtension(file) {
      const type = (file && file.type ? file.type : '').toLowerCase();
      if (type) {
        if (type === 'image/jpeg') return '.jpg';
        if (type.startsWith('image/')) {
          const subtype = type.slice(6);
          const clean = subtype.includes('+') ? subtype.split('+')[0] : subtype;
          return normalizeExtension(clean);
        }
      }
      const name = (file && file.name ? file.name : '').toLowerCase();
      const match = name.match(/(\.[a-z0-9]{2,5})$/);
      if (match) return match[1];
      return '.png';
    }

    function loadImageElement(url) {
      return new Promise((resolve, reject) => {
        const img = new Image();
        img.onload = () => resolve(img);
        img.onerror = (err) => reject(err);
        img.src = url;
      });
    }

    function getMousePos(e, el) {
      const rect = el.getBoundingClientRect();
      const x = (e.clientX - rect.left) * (el.width / rect.width);
      const y = (e.clientY - rect.top) * (el.height / rect.height);
      return { x, y };
    }

    function normalizeRect(x1, y1, x2, y2) {
      const x = Math.min(x1, x2);
      const y = Math.min(y1, y2);
      const w = Math.abs(x2 - x1);
      const h = Math.abs(y2 - y1);
      return { x, y, w, h };
    }

  });
</script>
</body>
</html>
