<!doctype html>
<!--
  Anonimizador de PDF — Copyright (C) 2025 Juan José de Haro
  Licencia del código: GNU Affero General Public License v3.0 (AGPL-3.0)
-->
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="icon" type="image/svg+xml" href="./favicon.svg" />
  <title>Anonimizador de PDF e imágenes — cliente</title>
  <style>
    :root { color-scheme: light dark; }
    * { box-sizing: border-box; }
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Arial, "Apple Color Emoji", "Segoe UI Emoji"; margin: 0; }
    header { position: sticky; top: 0; padding: .75rem 1rem; border-bottom: 1px solid #8883; backdrop-filter: blur(6px); background: color-mix(in srgb, canvas 92%, canvastext 8%); z-index: 30; }
    .headerBar { display: flex; align-items: center; gap: 1.25rem; flex-wrap: wrap; }
    .headerBrand { display: flex; align-items: center; gap: .6rem; min-width: 200px; }
    .headerToolbar { flex: 1 1 320px; display: flex; align-items: center; justify-content: center; gap: .75rem; flex-wrap: wrap; }
    main { display: grid; grid-template-columns: 360px 1fr; gap: 1rem; padding: 1rem; transition: grid-template-columns .35s ease; align-items: flex-start; }
    @media (max-width: 900px){ main { grid-template-columns: 1fr; } }
    .panel { border: 1px solid #8884; border-radius: .75rem; padding: .75rem; background: color-mix(in srgb, canvas 96%, canvastext 4%); }
    main > .panel { min-height: 0; }
    .langSelector { margin-left: auto; display: flex; align-items: center; gap: .4rem; font-size: .9rem; }
    .langSelector span { font-weight: 600; }
    .langSelector select { padding: .4rem .6rem; border-radius: .5rem; min-width: 7rem; }
    .row { display: flex; gap: .5rem; flex-wrap: wrap; align-items: center; }
    button, input[type="number"], input[type="file"], select { padding: .5rem .6rem; border-radius: .5rem; border: 1px solid #8884; background: inherit; }
    select { background: color-mix(in srgb, canvas 97%, canvastext 3%); }
    select:disabled { background: color-mix(in srgb, canvas 94%, canvastext 6%); }
    #zoomDisplay { padding: .5rem .6rem; padding-right: 1.8rem; border-radius: .5rem; border: 1px solid #8884; background: inherit; color: inherit; text-align: right; width: 5rem; }
    #zoomDisplay:focus-visible { outline: 2px solid #16a34a; outline-offset: 2px; }
    #zoomDisplay:disabled { opacity: .55; cursor: not-allowed; }
    .zoomInputWrapper { position: relative; display: inline-flex; align-items: center; }
    .zoomInputWrapper .zoomSuffix { position: absolute; right: .55rem; pointer-events: none; font-size: .9rem; color: color-mix(in srgb, canvastext 70%, transparent 30%); }
    button { cursor: pointer; }
    .panelToggle { width: 2.4rem; height: 2.4rem; border-radius: 50%; display: inline-flex; align-items: center; justify-content: center; padding: 0; border: 1px solid color-mix(in srgb, #16a34a 35%, transparent 65%); background: color-mix(in srgb, canvas 93%, #16a34a 7%); color: color-mix(in srgb, canvastext 88%, #0f2716 12%); box-shadow: 0 1px 4px #0002; transition: background .2s ease, color .2s ease, transform .2s ease; flex: 0 0 2.4rem; position: relative; }
    .panelToggle svg { width: 1.35rem; height: 1.35rem; }
    #toggleControls .icon-show { display: none; }
    body.controlsHidden #toggleControls .icon-hide { display: none; }
    body.controlsHidden #toggleControls .icon-show { display: block; }
    .panelToggle:hover { background: color-mix(in srgb, canvas 88%, #16a34a 12%); }
    .panelToggle:focus-visible { outline: 2px solid #16a34a; outline-offset: 2px; }
    #export { font-weight: 600; background: #5cb85c; border-color: #4aa34a; color: #ffffff; }
    #export:hover:not(:disabled) { background: #4aa34a; border-color: #3f8d3f; }
    #btnClearRects { background: color-mix(in srgb, canvas 90%, #16a34a 10%); border-color: color-mix(in srgb, #16a34a 22%, transparent 78%); color: color-mix(in srgb, canvastext 90%, #0f2716 10%); }
    #export:disabled,
    #btnClearRects:disabled { opacity: .6; cursor: not-allowed; }
    .fileDrop { flex: 1 1 200px; display: flex; align-items: center; justify-content: center; gap: .5rem; border: 1px dashed color-mix(in srgb, canvastext 40%, transparent 60%); border-radius: .65rem; padding: .6rem .75rem; min-height: 3.25rem; background: color-mix(in srgb, canvas 94%, #16a34a 6%); cursor: pointer; transition: border-color .2s ease, background .2s ease, color .2s ease; text-align: center; }
    .fileDrop.hasFile { background: inherit; border-style: solid; border-color: color-mix(in srgb, #5cb85c 55%, transparent 45%); color: #5cb85c; font-weight: 600; }
    .fileDrop.hasFile:hover { border-color: color-mix(in srgb, #4aa34a 60%, transparent 40%); background: inherit; color: #4aa34a; }
    .fileDrop:hover { border-color: color-mix(in srgb, #16a34a 55%, transparent 45%); background: color-mix(in srgb, canvas 90%, #16a34a 10%); }
    .fileDrop.dragging { border-color: color-mix(in srgb, #16a34a 70%, transparent 30%); background: color-mix(in srgb, canvas 85%, #16a34a 15%); color: color-mix(in srgb, canvastext 92%, #0f2716 8%); }
    .fileDropInput { display: none; }
    .muted { opacity: .8; font-size: .92rem; }
    .kbd { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace; background: #8882; border: 1px solid #8884; padding: 0 .35rem; border-radius: .35rem; }
    fieldset { border: none; margin: 0; padding: 0; }
    .namingField { display: flex; gap: .75rem; flex-wrap: wrap; align-items: center; }
    .namingField legend { font-size: .92rem; font-weight: 600; margin-right: .25rem; }
    .namingField label { display: inline-flex; align-items: center; gap: .35rem; }
    .panelCollapsible { border: 1px solid color-mix(in srgb, canvastext 22%, transparent 78%); border-radius: .65rem; margin-bottom: .75rem; background: color-mix(in srgb, canvas 92%, canvastext 8%); }
    .panelCollapsible summary { display: flex; align-items: center; justify-content: space-between; gap: .75rem; padding: .65rem .85rem; font-size: .92rem; font-weight: 600; cursor: pointer; list-style: none; }
    .panelCollapsible summary:focus-visible { outline: 2px solid #16a34a; outline-offset: 3px; }
    .panelCollapsible summary::-webkit-details-marker { display: none; }
    .panelCollapsible summary::after { content: '\25BE'; font-size: .8rem; transition: transform .2s ease; }
    .panelCollapsible[open] summary::after { transform: rotate(-180deg); }
    .panelCollapsible .collapsibleBody { padding: 0 .85rem 0; border-top: 1px solid transparent; display: flex; flex-direction: column; gap: .6rem; max-height: 0; opacity: 0; overflow: hidden; transition: max-height .28s ease, opacity .24s ease, padding-top .24s ease, padding-bottom .24s ease, border-top-color .24s ease; }
    .panelCollapsible[open] .collapsibleBody { padding: .6rem .85rem .75rem; max-height: 420px; opacity: 1; border-top-color: color-mix(in srgb, canvastext 18%, transparent 82%); }
    .panelCollapsible .rectControls { display: flex; gap: .75rem; flex-wrap: wrap; align-items: flex-start; }
    .panelCollapsible .rectStack { display: flex; flex-direction: column; gap: .4rem; min-width: 11rem; }
    .usageList { margin: 0; padding-left: 1.2rem; }
    .usageList li { margin-bottom: .35rem; }
    .usageList li:last-child { margin-bottom: 0; }
    .panelControls { position: relative; transition: transform .35s ease, opacity .25s ease; background: color-mix(in srgb, canvas 92%, canvastext 8%); }
    .panelTopRow { align-items: stretch; }
    .panelTopRow .fileDrop { flex: 1 1 auto; }
    .panelViewer { position: relative; display: flex; flex-direction: column; }
    #viewerContainer { position: relative; overflow-y: auto; padding: 1rem .5rem 1.5rem; min-height: 420px; flex: 1 1 auto; }
    #pagesContainer { display: flex; flex-direction: column; gap: 1.5rem; align-items: center; }
    #showControls { margin-left: .5rem; opacity: 0; visibility: hidden; pointer-events: none; transition: opacity .2s ease; display: none; }
    #zoomOverlay,
    .searchOverlay { display: inline-flex; align-items: center; gap: .35rem; padding: .35rem .6rem; border-radius: .6rem; border: 1px solid #8886; box-shadow: 0 6px 16px #0005; background: color-mix(in srgb, canvas 65%, #222 35%); backdrop-filter: blur(6px); min-height: 2.5rem; }
    #zoomOverlay button,
    .searchOverlay button { background: color-mix(in srgb, canvas 55%, #000 45%); color: inherit; border-radius: .5rem; border: 1px solid #8886; min-width: 2.1rem; }
    .searchOverlay input { border-radius: .5rem; border: 1px solid color-mix(in srgb, #fff 25%, transparent 75%); background: color-mix(in srgb, canvas 55%, #111 45%); color: inherit; padding: .4rem .55rem; min-width: 11rem; }
    .searchOverlay input:disabled { opacity: .55; cursor: not-allowed; }
    .searchOverlay button { padding: .35rem .55rem; font-size: 1rem; line-height: 1; min-width: 2rem; cursor: pointer; }
    .searchOverlay .searchNav { min-width: 2rem; padding: .35rem .45rem; }
    .searchOverlay button:disabled { opacity: .45; cursor: not-allowed; }
    .viewerSearchGroup { display: inline-flex; flex-direction: column; gap: .25rem; align-items: center; }
    .viewerSearchGroup .searchOverlay { align-self: stretch; }
    .searchStatus { font-size: .85rem; opacity: .8; text-align: center; min-width: 7rem; display: block; line-height: 1.1; }
    .srOnly { position: absolute; width: 1px; height: 1px; padding: 0; margin: -1px; overflow: hidden; clip: rect(0, 0, 0, 0); white-space: nowrap; border: 0; }
    body.controlsHidden main { grid-template-columns: 0px 1fr; }
    body.controlsHidden .panelControls { transform: translateX(-2rem); opacity: 0; pointer-events: none; }
    body.controlsHidden #showControls { display: inline-flex; opacity: 1; visibility: visible; pointer-events: auto; }
    @media (prefers-color-scheme: light) {
      .panelControls { background: #f2f3f5; }
      .panel { background: #f9fafb; }
      #zoomOverlay,
      .searchOverlay { background: color-mix(in srgb, canvas 95%, #666 5%); border-color: color-mix(in srgb, #000 18%, transparent 82%); box-shadow: 0 6px 18px #0002; }
      #zoomOverlay button,
      .searchOverlay button { background: color-mix(in srgb, canvas 98%, #666 2%); border-color: color-mix(in srgb, #000 25%, transparent 75%); color: color-mix(in srgb, canvastext 92%, #000 8%); }
      .searchOverlay input { background: color-mix(in srgb, canvas 99%, #666 1%); border-color: color-mix(in srgb, #000 20%, transparent 80%); color: color-mix(in srgb, canvastext 92%, #000 8%); }
      .panelCollapsible { background: color-mix(in srgb, canvas 98%, #666 2%); border-color: color-mix(in srgb, #000 18%, transparent 82%); }
      .panelCollapsible[open] .collapsibleBody { border-top-color: color-mix(in srgb, #000 18%, transparent 82%); }
      #zoomOverlay button:disabled { opacity: .55; }
    }
    #zoomOverlay button:disabled,
    .searchOverlay button:disabled { opacity: .45; }
    .pageView { position: relative; }
    .pageView img { display: block; border: 1px solid #8884; border-radius: .5rem; background: #fff; user-select: none; }
    .pageView .pdfPageCanvas { display: none; }
    .pageView .pdfOverlay { position: absolute; inset: 0; pointer-events: auto; border-radius: .5rem; cursor: crosshair; z-index: 2; display: block; }
    .pageView.active { outline: 2px solid #16a34a; outline-offset: 6px; }
    .badget { font-size: .85rem; opacity: .8; }
    footer { padding: .75rem 1rem; border-top: 1px solid #8883; }
    #profModal { position: fixed; inset: 0; display: flex; align-items: center; justify-content: center; background: color-mix(in srgb, #000 55%, transparent 45%); backdrop-filter: blur(4px); padding: 1.5rem; z-index: 999; opacity: 0; pointer-events: none; transition: opacity .25s ease; }
    #profModal.active { opacity: 1; pointer-events: auto; }
    #profModal .modalDialog { max-width: 640px; width: min(100%, 640px); background: color-mix(in srgb, canvas 92%, #16a34a 8%); color: inherit; border: 1px solid color-mix(in srgb, #16a34a 35%, transparent 65%); border-radius: .9rem; box-shadow: 0 14px 32px #0006; padding: 1.2rem 1.4rem 1.5rem; display: flex; flex-direction: column; gap: .85rem; position: relative; }
    #profModal h2 { margin: 0; font-size: 1.2rem; }
    #profModal p { margin: 0; line-height: 1.55; }
    #profModal button.modalClose { align-self: flex-end; border: none; background: none; color: inherit; font-size: .95rem; cursor: pointer; padding: .35rem .6rem; border-radius: .5rem; transition: background .2s ease; }
    #profModal button.modalClose:hover { background: color-mix(in srgb, canvas 85%, #16a34a 15%); }
    .infoLink { color: inherit; text-decoration: underline; font-size: .9rem; cursor: pointer; border: none; background: none; padding: 0; }
    .panelInfoLink { margin-left: .35rem; align-self: center; }
  </style>
  <!-- Bibliotecas locales para funcionar sin conexión -->
  <script src="./vendor/pdfjs/pdf.v216.min.js" defer></script>
  <script src="./vendor/jspdf/jspdf.umd.min.js" defer></script>
  <script src="./vendor/jszip/jszip.min.js" defer></script>
</head>
<body>
  <header class="headerBar">
    <div class="headerBrand">
      <img src="./favicon.svg" alt="" width="32" height="32" aria-hidden="true" />
      <strong data-i18n="app.headerTitle">Anonimizador de PDF e imágenes</strong>
      <button id="showControls" class="panelToggle panelToggle-show" type="button" aria-pressed="false" title="Mostrar panel de controles">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
          <rect x="3" y="3" width="2" height="18" rx="1" />
          <path d="M10 8l4 4-4 4" />
        </svg>
      </button>
    </div>
    <div class="headerToolbar">
      <div id="zoomOverlay">
        <span data-i18n="viewer.zoom.label">Zoom:</span>
        <button id="zoomOut" type="button" disabled>-</button>
        <span class="zoomInputWrapper">
          <input id="zoomDisplay" type="text" inputmode="decimal" autocomplete="off" aria-label="Porcentaje de zoom" data-i18n-attr-aria-label="viewer.zoom.inputLabel" value="100" />
          <span class="zoomSuffix">%</span>
        </span>
        <button id="zoomIn" type="button" disabled>+</button>
        <button id="zoomFit" type="button" disabled data-i18n="viewer.zoom.fit">Ajustar ancho</button>
      </div>
      <div class="viewerSearchGroup">
        <form id="searchForm" class="searchOverlay" role="search">
          <label for="searchInput" class="srOnly" data-i18n="viewer.search.label">Buscar en el documento</label>
          <input id="searchInput" type="search" autocomplete="off" placeholder="Buscar texto" data-i18n-attr-placeholder="viewer.search.placeholder" />
          <button id="searchPrev" class="searchNav" type="button" aria-label="Coincidencia anterior" title="Coincidencia anterior" data-i18n-attr-aria-label="viewer.search.prevLabel" data-i18n-attr-title="viewer.search.prevLabel" disabled>&lsaquo;</button>
          <button id="searchNext" class="searchNav" type="button" aria-label="Coincidencia siguiente" title="Coincidencia siguiente" data-i18n-attr-title="viewer.search.nextLabel" data-i18n-attr-aria-label="viewer.search.nextLabel" disabled>&rsaquo;</button>
          <button id="searchClear" type="button" aria-label="Limpiar búsqueda" data-i18n-attr-aria-label="viewer.search.clearLabel" disabled>×</button>
        </form>
        <span id="searchStatus" class="searchStatus" aria-live="polite"></span>
      </div>
    </div>
    <label for="languageSelect" class="langSelector">
      <span data-i18n="lang.label">Idioma</span>
      <select id="languageSelect">
        <option value="es">Español</option>
        <option value="ca">Català</option>
        <option value="gl">Galego</option>
        <option value="eu">Euskara</option>
        <option value="en">English</option>
      </select>
    </label>
  </header>

  <main>
    <section class="panel panelControls">
      <div class="row panelTopRow" style="margin-bottom:.5rem">
        <button id="toggleControls" class="panelToggle panelToggle-collapse" type="button" aria-pressed="false" title="Ocultar panel de controles">
          <svg class="icon-hide" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
            <rect x="3" y="3" width="6" height="18" rx="2" />
            <path d="M14 8l-4 4 4 4" />
          </svg>
          <svg class="icon-show" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
            <rect x="3" y="3" width="2" height="18" rx="1" />
            <path d="M10 8l4 4-4 4" />
          </svg>
        </button>
        <button id="openProfModal" class="infoLink panelInfoLink" type="button" data-i18n="info.noticeButton">Aviso importante</button>
        <div id="fileDrop" class="fileDrop">
          <input id="file" class="fileDropInput" type="file" accept="application/pdf,image/*" />
          <span data-i18n="drop.default">Arrastra un PDF o imagen o haz clic para abrirlo</span>
        </div>
      </div>
      <div class="row" style="margin-bottom:.5rem; justify-content:flex-start">
        <div><span data-i18n="status.page">Página</span> <span id="pageNum">-</span><span> / </span><span id="pageCount">-</span></div>
      </div>
      <details class="panelCollapsible" id="usageSection">
        <summary data-i18n="controls.usage.title">Instrucciones</summary>
        <div class="collapsibleBody">
          <div class="muted" style="margin:0" data-i18n="controls.usage.help" data-i18n-type="html"></div>
        </div>
      </details>
      <details class="panelCollapsible" id="rectSection">
        <summary data-i18n="controls.rect.title">Configuración del rectángulo</summary>
        <div class="collapsibleBody">
          <div class="rectControls">
            <label>
              <span data-i18n="controls.rect.stroke">Grosor del borde:</span>
              <input id="strokeW" type="number" min="1" max="8" value="2" style="width:4.5rem" />
            </label>
            <div class="rectStack">
              <label>
                <span data-i18n="controls.rect.opacity">Opacidad tapa:</span>
                <input id="opacity" type="number" min="0.1" max="1" step="0.1" value="1" style="width:4.5rem" />
              </label>
            </div>
            <select id="maskColor" title="Color de la máscara" data-i18n-attr-title="controls.rect.colorTitle">
              <option value="#000000" selected data-i18n="controls.rect.color.black">Negro</option>
              <option value="#ffffff" data-i18n="controls.rect.color.white">Blanco</option>
              <option value="#888888" data-i18n="controls.rect.color.gray">Gris</option>
            </select>
          </div>
        </div>
      </details>
      <button id="btnClearRects" disabled style="margin-bottom:.75rem" data-i18n="controls.clearButton">Limpiar rectángulos de esta página</button>
      <fieldset class="namingField" style="margin-bottom:.75rem">
        <legend data-i18n="naming.legend">Nombre del archivo exportado</legend>
        <label>
          <input type="radio" name="namingOption" value="derived" checked />
          <span data-i18n="naming.option.derived">Mismo nombre + _anonim</span>
        </label>
        <label>
          <input type="radio" name="namingOption" value="fixed" />
          <span data-i18n="naming.option.fixed">anonim.pdf</span>
        </label>
      </fieldset>
      <div class="row" style="margin-bottom:.5rem">
        <select id="exportMode" aria-label="Formato de exportación" disabled style="min-width:12rem" data-i18n-attr-aria-label="export.selector.label">
          <option value="pdf" data-i18n="export.mode.pdf">Formato PDF</option>
          <option value="zip" data-i18n="export.mode.zip">ZIP con un PNG por página</option>
          <option value="png" data-i18n="export.mode.pngImage">Imagen PNG anonimizada</option>
        </select>
        <button id="export" disabled data-i18n="export.button.default">Exportar anonimizado</button>
        <a id="dlLink" download style="display:none"></a>
      </div>
      <p id="exportNotice" class="muted" style="display:none; margin-top:-.25rem; margin-bottom:.75rem;"></p>
      <details>
        <summary data-i18n="details.security.title">Notas sobre seguridad del anonimizado</summary>
        <ul>
          <li data-i18n="details.security.item1">La exportación genera un PDF de imágenes (rasterizado). El texto original desaparece: ya no es seleccionable ni extraíble como texto.</li>
          <li data-i18n="details.security.item2">Esto es adecuado para ocultar nombres propios de trabajos entregados, con la contrapartida de mayor tamaño y pérdida de accesibilidad.</li>
          <li data-i18n="details.security.item3">Uso totalmente local en tu navegador.</li>
        </ul>
      </details>

      <details>
        <summary data-i18n="details.credits.title">Créditos y soporte</summary>
        <p class="muted" data-i18n="details.credits.contact" data-i18n-type="html">¿Dudas o sugerencias? Pulsa el botón verde <a href="https://github.com/jjdeharo/anonim-pdf/issues" style="color:inherit; text-decoration:underline;">New issue</a> en GitHub.</p>
        <p class="muted" data-i18n="details.credits.owner" data-i18n-type="html">Anonimizador de PDF · © 2025 <a href="https://bilateria.es" style="color:inherit; text-decoration:underline;">Juan José de Haro</a> · Recurso: <a href="https://github.com/jjdeharo/anonim-pdf" style="color:inherit; text-decoration:underline;">github.com/jjdeharo/anonim-pdf</a></p>
        <p class="muted" data-i18n="details.credits.license" data-i18n-type="html"><a href="./LICENSE.txt" style="color:inherit; text-decoration:underline;">Licencia del código: AGPL v3</a></p>
      </details>

    </section>

    <section class="panel panelViewer">
      <div id="viewerContainer">
        <div id="pagesContainer"></div>
      </div>
    </section>
  </main>

  <div id="profModal" role="dialog" aria-modal="true" aria-labelledby="profModalTitle" aria-describedby="profModalBody">
    <div class="modalDialog">
      <button id="closeProfModal" class="modalClose" type="button" data-i18n="modal.close">Cerrar aviso</button>
      <h2 id="profModalTitle" data-i18n="modal.title">Aviso importante</h2>
      <div id="profModalBody" style="display:flex; flex-direction:column; gap:1rem;">
        <p data-i18n="modal.body1" data-i18n-type="html">Esta aplicación ofrece herramientas para que el usuario pueda anonimizar un PDF o una imagen, permitiéndole ocultar manualmente los datos identificativos del alumnado antes de generar un nuevo documento. De esta forma, los archivos pueden emplearse en herramientas de inteligencia artificial sin exponer información personal.</p>
        <p data-i18n="modal.body2" data-i18n-type="html">La inteligencia artificial puede servir de apoyo para obtener análisis parciales, detectar patrones o aportar nuevas perspectivas sobre los trabajos del alumnado. <strong>No debe confundirse su uso con la función docente</strong>: la IA no evalúa, no corrige y no puede asumir la responsabilidad educativa.</p>
        <p data-i18n="modal.body3" data-i18n-type="html"><strong>La evaluación, el juicio pedagógico y la calificación del alumnado corresponden siempre al profesorado.</strong> La IA puede complementar la reflexión, pero nunca sustituir el criterio profesional ni la decisión final del docente.</p>
      </div>
    </div>
  </div>

  <footer class="muted"></footer>

<script>
  window.addEventListener('DOMContentLoaded', () => {
    const LANG_STORAGE_KEY = 'anonim-pdf-lang';
    const SUPPORTED_LOCALES = ['es', 'ca', 'gl', 'eu', 'en'];
    const FALLBACK_LOCALE = 'es';
    const LOCALE_INTL = { es: 'es-ES', ca: 'ca-ES', gl: 'gl-ES', eu: 'eu-ES', en: 'en' };
    const TRANSLATIONS = {
      es: {
        'app.windowTitle': `Anonimizador de PDF e imágenes — cliente`,
        'app.headerTitle': `Anonimizador de PDF e imágenes`,
        'lang.label': `Idioma`,
        'info.noticeButton': `Aviso importante`,
        'drop.default': `Arrastra un PDF o imagen o haz clic para abrirlo`,
        'status.page': `Página`,
        'controls.usage.title': `Instrucciones`,
        'controls.usage.help': `<ol class="usageList"><li>Arrastra con el <strong>botón izquierdo</strong> para dibujar un rectángulo en la página actual.</li><li>Arrastra con el <strong>botón derecho</strong> para dibujar el mismo rectángulo en la <strong>misma posición en todas las páginas</strong> del PDF.</li><li>Haz <strong>doble clic</strong> sobre un rectángulo para borrarlo.</li><li>Pulsa el botón <strong>“Limpiar rectángulos de esta página”</strong> para borrar todos los rectángulos de la página actual.</li></ol>`,
        'controls.rect.title': `Configuración del rectángulo`,
        'controls.rect.stroke': `Grosor del borde:`,
        'controls.rect.opacity': `Opacidad tapa:`,
        'controls.rect.colorTitle': `Color de la máscara`,
        'controls.rect.color.black': `Negro`,
        'controls.rect.color.white': `Blanco`,
        'controls.rect.color.gray': `Gris`,
        'controls.clearButton': `Limpiar rectángulos de esta página`,
        'naming.legend': `Nombre del archivo exportado`,
        'naming.option.derived': `Mismo nombre + _anonim`,
        'naming.option.fixed': `anonim.pdf`,
        'export.button.default': `Exportar anonimizado`,
        'export.button.withTarget': `Exportar {target}`,
        'export.mode.pdf': `Formato PDF`,
        'export.mode.zip': `ZIP con un PNG por página`,
        'export.mode.pngSingle': `PNG con todas las páginas`,
        'export.mode.pngImage': `Imagen PNG anonimizada`,
        'export.selector.label': `Formato de exportación`,
        'details.security.title': `Notas sobre seguridad del anonimizado`,
        'details.security.item1': `La exportación genera un PDF de imágenes (rasterizado). El texto original desaparece: ya no es seleccionable ni extraíble como texto.`,
        'details.security.item2': `Esto es adecuado para ocultar nombres propios de trabajos entregados, con la contrapartida de mayor tamaño y pérdida de accesibilidad.`,
        'details.security.item3': `Uso totalmente local en tu navegador.`,
        'details.credits.title': `Créditos y soporte`,
        'details.credits.contact': `¿Dudas o sugerencias? Pulsa el botón verde <a href="https://github.com/jjdeharo/anonim-pdf/issues" style="color:inherit; text-decoration:underline;">New issue</a> en GitHub.`,
        'details.credits.owner': `Anonimizador de PDF · © 2025 <a href="https://bilateria.es" style="color:inherit; text-decoration:underline;">Juan José de Haro</a> · Recurso: <a href="https://github.com/jjdeharo/anonim-pdf" style="color:inherit; text-decoration:underline;">github.com/jjdeharo/anonim-pdf</a>`,
        'details.credits.license': `<a href="./LICENSE.txt" style="color:inherit; text-decoration:underline;">Licencia del código: AGPL v3</a>`,
        'viewer.zoom.label': `Zoom:`,
        'viewer.zoom.inputLabel': `Porcentaje de zoom`,
        'viewer.zoom.fit': `Ajustar ancho`,
        'viewer.search.label': `Buscar en el documento`,
        'viewer.search.placeholder': `Buscar texto…`,
        'viewer.search.clearLabel': `Limpiar búsqueda`,
        'viewer.search.matchOne': `1 coincidencia`,
        'viewer.search.matches': `{matches} coincidencias`,
        'viewer.search.noResults': `Sin coincidencias`,
        'viewer.search.searching': `Buscando…`,
        'viewer.search.disabled': `Disponible solo para documentos PDF`,
        'viewer.search.prevLabel': `Coincidencia anterior`,
        'viewer.search.nextLabel': `Coincidencia siguiente`,
        'viewer.search.indexed': `{current}/{total} coincidencias`,
        'modal.close': `Cerrar aviso`,
        'modal.title': `Aviso importante`,
        'modal.body1': `Esta aplicación ofrece herramientas para que el usuario pueda anonimizar un PDF o una imagen, permitiéndole ocultar manualmente los datos identificativos del alumnado antes de generar un nuevo documento. De esta forma, los archivos pueden emplearse en herramientas de inteligencia artificial sin exponer información personal.`,
        'modal.body2': `La inteligencia artificial puede servir de apoyo para obtener análisis parciales, detectar patrones o aportar nuevas perspectivas sobre los trabajos del alumnado. <strong>No debe confundirse su uso con la función docente</strong>: la IA no evalúa, no corrige y no puede asumir la responsabilidad educativa.`,
        'modal.body3': `<strong>La evaluación, el juicio pedagógico y la calificación del alumnado corresponden siempre al profesorado.</strong> La IA puede complementar la reflexión, pero nunca sustituir el criterio profesional ni la decisión final del docente.`,
        'alerts.pdfjsMissing': `No se pudo cargar pdf.js. Comprueba la conexión o políticas de bloqueadores. He cambiado al build legacy para exponer "pdfjsLib".`,
        'alerts.pdfjsWorkerWarning': `Fallo al configurar worker pdf.js, usando modo sin worker.`,
        'alerts.exportError': `Ocurrió un error exportando el documento anonimizado.`,
        'alerts.exportErrorLog': `Error durante la exportación.`,
        'alerts.jsPdfMissing': `No se pudo cargar la librería jsPDF.`,
        'alerts.jsZipMissing': `No se pudo cargar la librería JSZip.`,
        'alerts.pngScaleNotice': `El PNG único se generará con menor resolución por la longitud del documento. Revisa que el resultado sea legible.`,
        'alerts.singlePngFail': `No se pudo generar la imagen única anonimizada.`,
        'alerts.imagePngFail': `No se pudo generar la imagen anonimizada.`,
        'alerts.invalidFileType': `Selecciona un archivo PDF o una imagen (PNG, JPG, WEBP…).`,
        'alerts.fileReadFailed': `No se pudo leer el archivo. Prueba con otro PDF.`,
        'alerts.pdfOpenError': `No se pudo abrir el PDF: {error}`,
        'alerts.imageOpenError': `No se pudo abrir la imagen. Prueba con otro archivo.`,
        'alerts.imageGenericError': `No se pudo abrir la imagen.`,
        'alerts.imageSizeUnknown': `No se pudo determinar el tamaño de la imagen.`,
        'alerts.pdfLoadErrorLog': `Error cargando PDF`,
        'alerts.imageLoadErrorLog': `No se pudo cargar la imagen seleccionada.`,
        'alerts.fileReadErrorLog': `No se pudo leer el archivo soltado/seleccionado.`,
        'alerts.syncInputWarn': `No se pudo sincronizar input de archivo con el drop.`,
        'controls.toggle.show': `Mostrar panel de controles`,
        'controls.toggle.hide': `Ocultar panel de controles`,
        'controls.toggle.showButton': `Mostrar panel de controles`,
        'export.notice.pngSingle': `Generará una única imagen PNG apilando las {pages} páginas (ancho máximo {width}px y alto limitado a {height}px para que la IA lea el contenido). Puede tardar unos segundos.`,
        'defaults.document': `documento`,
        'defaults.documentPdf': `documento.pdf`,
      },
      ca: {
        'app.windowTitle': `Anonimitzador de PDF i imatges — client`,
        'app.headerTitle': `Anonimitzador de PDF i imatges`,
        'lang.label': `Idioma`,
        'info.noticeButton': `Avís important`,
        'drop.default': `Arrossega un PDF o una imatge o fes clic per obrir-la`,
        'status.page': `Pàgina`,
        'controls.usage.title': `Instruccions`,
        'controls.usage.help': `<ol class="usageList"><li>Arrossega amb el <strong>botó esquerre</strong> per dibuixar un rectangle a la pàgina actual.</li><li>Arrossega amb el <strong>botó dret</strong> per dibuixar el mateix rectangle a la <strong>mateixa posició a totes les pàgines</strong> del PDF.</li><li>Fes <strong>doble clic</strong> sobre un rectangle per esborrar-lo.</li><li>Prem el botó <strong>“Neteja els rectangles d'aquesta pàgina”</strong> per esborrar tots els rectangles de la pàgina actual.</li></ol>`,
        'controls.rect.title': `Configuració del rectangle`,
        'controls.rect.stroke': `Gruix del contorn:`,
        'controls.rect.opacity': `Opacitat de la cobertura:`,
        'controls.rect.colorTitle': `Color de la màscara`,
        'controls.rect.color.black': `Negre`,
        'controls.rect.color.white': `Blanc`,
        'controls.rect.color.gray': `Gris`,
        'controls.clearButton': `Neteja els rectangles d'aquesta pàgina`,
        'naming.legend': `Nom del fitxer exportat`,
        'naming.option.derived': `Mateix nom + _anonim`,
        'naming.option.fixed': `anonim.pdf`,
        'export.button.default': `Exporta anonimitzat`,
        'export.button.withTarget': `Exporta {target}`,
        'export.mode.pdf': `Format PDF`,
        'export.mode.zip': `ZIP amb un PNG per pàgina`,
        'export.mode.pngSingle': `PNG amb totes les pàgines`,
        'export.mode.pngImage': `Imatge PNG anonimitzada`,
        'export.selector.label': `Format d'exportació`,
        'details.security.title': `Notes sobre la seguretat de l'anonimització`,
        'details.security.item1': `L'exportació genera un PDF d'imatges (rasteritzat). El text original desapareix: ja no és seleccionable ni es pot extreure com a text.`,
        'details.security.item2': `És adequat per ocultar noms propis de treballs entregats, amb la contrapartida d'un pes més gran i pèrdua d'accessibilitat.`,
        'details.security.item3': `Ús totalment local al teu navegador.`,
        'details.credits.title': `Crèdits i suport`,
        'details.credits.contact': `Dubtes o suggeriments? Prem el botó verd <a href="https://github.com/jjdeharo/anonim-pdf/issues" style="color:inherit; text-decoration:underline;">New issue</a> a GitHub.`,
        'details.credits.owner': `Anonimitzador de PDF · © 2025 <a href="https://bilateria.es" style="color:inherit; text-decoration:underline;">Juan José de Haro</a> · Recurs: <a href="https://github.com/jjdeharo/anonim-pdf" style="color:inherit; text-decoration:underline;">github.com/jjdeharo/anonim-pdf</a>`,
        'details.credits.license': `<a href="./LICENSE.txt" style="color:inherit; text-decoration:underline;">Llicència del codi: AGPL v3</a>`,
        'viewer.zoom.label': `Zoom:`,
        'viewer.zoom.inputLabel': `Percentatge de zoom`,
        'viewer.zoom.fit': `Ajusta l'amplada`,
        'viewer.search.label': `Cercar al document`,
        'viewer.search.placeholder': `Cerca de text…`,
        'viewer.search.clearLabel': `Neteja la cerca`,
        'viewer.search.matchOne': `1 coincidència`,
        'viewer.search.matches': `{matches} coincidències`,
        'viewer.search.noResults': `Sense coincidències`,
        'viewer.search.searching': `Cercant…`,
        'viewer.search.disabled': `Disponible només per a documents PDF`,
        'viewer.search.prevLabel': `Coincidència anterior`,
        'viewer.search.nextLabel': `Coincidència següent`,
        'viewer.search.indexed': `{current}/{total} coincidències`,
        'modal.close': `Tanca l'avís`,
        'modal.title': `Avís important`,
        'modal.body1': `Aquesta aplicació ofereix eines perquè l'usuari pugui anonimitzar un PDF o una imatge, permetent-li ocultar manualment les dades identificatives de l'alumnat abans de generar un document nou. D'aquesta manera, els fitxers es poden emprar en eines d'intel·ligència artificial sense exposar informació personal.`,
        'modal.body2': `La intel·ligència artificial pot servir de suport per obtenir anàlisis parcials, detectar patrons o aportar noves perspectives sobre els treballs de l'alumnat. <strong>No s'ha de confondre el seu ús amb la funció docent</strong>: la IA no avalua, no corregeix i no pot assumir la responsabilitat educativa.`,
        'modal.body3': `<strong>L'avaluació, el judici pedagògic i la qualificació de l'alumnat corresponen sempre al professorat.</strong> La IA pot complementar la reflexió, però mai substituir el criteri professional ni la decisió final del docent.`,
        'alerts.pdfjsMissing': `No s'ha pogut carregar pdf.js. Comprova la connexió o els bloquejadors. He canviat al build legacy per exposar "pdfjsLib".`,
        'alerts.pdfjsWorkerWarning': `Error en configurar el worker de pdf.js; s'utilitzarà el mode sense worker.`,
        'alerts.exportError': `S'ha produït un error en exportar el document anonimitzat.`,
        'alerts.exportErrorLog': `Error en l'exportació.`,
        'alerts.jsPdfMissing': `No s'ha pogut carregar la llibreria jsPDF.`,
        'alerts.jsZipMissing': `No s'ha pogut carregar la llibreria JSZip.`,
        'alerts.pngScaleNotice': `El PNG únic es generarà amb menys resolució per la longitud del document. Revisa que el resultat sigui llegible.`,
        'alerts.singlePngFail': `No s'ha pogut generar la imatge única anonimitzada.`,
        'alerts.imagePngFail': `No s'ha pogut generar la imatge anonimitzada.`,
        'alerts.invalidFileType': `Selecciona un fitxer PDF o una imatge (PNG, JPG, WEBP…).`,
        'alerts.fileReadFailed': `No s'ha pogut llegir el fitxer. Prova amb un altre PDF.`,
        'alerts.pdfOpenError': `No s'ha pogut obrir el PDF: {error}`,
        'alerts.imageOpenError': `No s'ha pogut obrir la imatge. Prova amb un altre fitxer.`,
        'alerts.imageGenericError': `No s'ha pogut obrir la imatge.`,
        'alerts.imageSizeUnknown': `No s'ha pogut determinar la mida de la imatge.`,
        'alerts.pdfLoadErrorLog': `Error en carregar el PDF`,
        'alerts.imageLoadErrorLog': `No s'ha pogut carregar la imatge seleccionada.`,
        'alerts.fileReadErrorLog': `No s'ha pogut llegir el fitxer arrossegat/seleccionat.`,
        'alerts.syncInputWarn': `No s'ha pogut sincronitzar l'entrada de fitxers amb l'arrossegament.`,
        'controls.toggle.show': `Mostra el panell de controls`,
        'controls.toggle.hide': `Oculta el panell de controls`,
        'controls.toggle.showButton': `Mostra el panell de controls`,
        'export.notice.pngSingle': `Generarà una única imatge PNG apilant les {pages} pàgines (amplada màxima {width}px i alçada limitada a {height}px perquè la IA en llegeixi el contingut). Pot trigar uns segons.`,
        'defaults.document': `document`,
        'defaults.documentPdf': `document.pdf`,
      },
      gl: {
        'app.windowTitle': `Anonimizador de PDF e imaxes — cliente`,
        'app.headerTitle': `Anonimizador de PDF e imaxes`,
        'lang.label': `Idioma`,
        'info.noticeButton': `Aviso importante`,
        'drop.default': `Arrastra un PDF ou unha imaxe ou fai clic para abrila`,
        'status.page': `Páxina`,
        'controls.usage.title': `Instrucións`,
        'controls.usage.help': `<ol class="usageList"><li>Arrastra co <strong>botón esquerdo</strong> para debuxar un rectángulo na páxina actual.</li><li>Arrastra co <strong>botón dereito</strong> para debuxar o mesmo rectángulo na <strong>mesma posición en todas as páxinas</strong> do PDF.</li><li>Fai <strong>dobre clic</strong> sobre un rectángulo para borralo.</li><li>Preme o botón <strong>“Limpar os rectángulos desta páxina”</strong> para borrar todos os rectángulos da páxina actual.</li></ol>`,
        'controls.rect.title': `Configuración do rectángulo`,
        'controls.rect.stroke': `Grosor do bordo:`,
        'controls.rect.opacity': `Opacidade da cuberta:`,
        'controls.rect.colorTitle': `Cor da máscara`,
        'controls.rect.color.black': `Negro`,
        'controls.rect.color.white': `Branco`,
        'controls.rect.color.gray': `Gris`,
        'controls.clearButton': `Limpar os rectángulos desta páxina`,
        'naming.legend': `Nome do ficheiro exportado`,
        'naming.option.derived': `Mesmo nome + _anonim`,
        'naming.option.fixed': `anonim.pdf`,
        'export.button.default': `Exportar anonimizado`,
        'export.button.withTarget': `Exportar {target}`,
        'export.mode.pdf': `Formato PDF`,
        'export.mode.zip': `ZIP cun PNG por páxina`,
        'export.mode.pngSingle': `PNG con todas as páxinas`,
        'export.mode.pngImage': `Imaxe PNG anonimizada`,
        'export.selector.label': `Formato de exportación`,
        'details.security.title': `Notas sobre a seguridade da anonimización`,
        'details.security.item1': `A exportación xera un PDF de imaxes (rasterizado). O texto orixinal desaparece: xa non é seleccionable nin extraíble como texto.`,
        'details.security.item2': `É axeitado para agochar nomes propios de traballos entregados, coa contrapartida dun maior tamaño e perda de accesibilidade.`,
        'details.security.item3': `Uso totalmente local no teu navegador.`,
        'details.credits.title': `Créditos e soporte`,
        'details.credits.contact': `Tes dúbidas ou suxestións? Preme o botón verde <a href="https://github.com/jjdeharo/anonim-pdf/issues" style="color:inherit; text-decoration:underline;">New issue</a> en GitHub.`,
        'details.credits.owner': `Anonimizador de PDF · © 2025 <a href="https://bilateria.es" style="color:inherit; text-decoration:underline;">Juan José de Haro</a> · Recurso: <a href="https://github.com/jjdeharo/anonim-pdf" style="color:inherit; text-decoration:underline;">github.com/jjdeharo/anonim-pdf</a>`,
        'details.credits.license': `<a href="./LICENSE.txt" style="color:inherit; text-decoration:underline;">Licenza do código: AGPL v3</a>`,
        'viewer.zoom.label': `Zoom:`,
        'viewer.zoom.inputLabel': `Porcentaxe de zoom`,
        'viewer.zoom.fit': `Axustar ancho`,
        'viewer.search.label': `Buscar no documento`,
        'viewer.search.placeholder': `Buscar texto…`,
        'viewer.search.clearLabel': `Limpar a busca`,
        'viewer.search.matchOne': `1 coincidencia`,
        'viewer.search.matches': `{matches} coincidencias`,
        'viewer.search.noResults': `Sen coincidencias`,
        'viewer.search.searching': `Buscando…`,
        'viewer.search.disabled': `Dispoñible só para documentos PDF`,
        'viewer.search.prevLabel': `Coincidencia anterior`,
        'viewer.search.nextLabel': `Coincidencia seguinte`,
        'viewer.search.indexed': `{current}/{total} coincidencias`,
        'modal.close': `Pechar aviso`,
        'modal.title': `Aviso importante`,
        'modal.body1': `Esta aplicación ofrece ferramentas para que a persoa usuaria poida anonimizar un PDF ou unha imaxe, permitíndolle ocultar manualmente os datos identificativos do alumnado antes de xerar un novo documento. Deste xeito, os arquivos poden empregarse en ferramentas de intelixencia artificial sen expor información persoal.`,
        'modal.body2': `A intelixencia artificial pode servir de apoio para obter análises parciais, detectar patróns ou achegar novas perspectivas sobre os traballos do alumnado. <strong>Non se debe confundir o seu uso coa función docente</strong>: a IA non avalía, non corrixe e non pode asumir a responsabilidade educativa.`,
        'modal.body3': `<strong>A avaliación, o xuízo pedagóxico e a cualificación do alumnado corresponden sempre ao profesorado.</strong> A IA pode complementar a reflexión, pero nunca substituír o criterio profesional nin a decisión final do docente.`,
        'alerts.pdfjsMissing': `Non se puido cargar pdf.js. Comproba a conexión ou os bloqueadores. Cambiei á versión legacy para expor "pdfjsLib".`,
        'alerts.pdfjsWorkerWarning': `Produciuse un erro ao configurar o worker de pdf.js; usarase o modo sen worker.`,
        'alerts.exportError': `Produciuse un erro ao exportar o documento anonimizado.`,
        'alerts.exportErrorLog': `Erro na exportación.`,
        'alerts.jsPdfMissing': `Non se puido cargar a biblioteca jsPDF.`,
        'alerts.jsZipMissing': `Non se puido cargar a biblioteca JSZip.`,
        'alerts.pngScaleNotice': `O PNG único xeraráse cunha resolución menor pola lonxitude do documento. Revisa que o resultado sexa lexible.`,
        'alerts.singlePngFail': `Non se puido xerar a imaxe única anonimizada.`,
        'alerts.imagePngFail': `Non se puido xerar a imaxe anonimizada.`,
        'alerts.invalidFileType': `Selecciona un ficheiro PDF ou unha imaxe (PNG, JPG, WEBP…).`,
        'alerts.fileReadFailed': `Non se puido ler o ficheiro. Proba con outro PDF.`,
        'alerts.pdfOpenError': `Non se puido abrir o PDF: {error}`,
        'alerts.imageOpenError': `Non se puido abrir a imaxe. Proba con outro ficheiro.`,
        'alerts.imageGenericError': `Non se puido abrir a imaxe.`,
        'alerts.imageSizeUnknown': `Non se puido determinar o tamaño da imaxe.`,
        'alerts.pdfLoadErrorLog': `Erro ao cargar o PDF`,
        'alerts.imageLoadErrorLog': `Non se puido cargar a imaxe seleccionada.`,
        'alerts.fileReadErrorLog': `Non se puido ler o ficheiro soltado/seleccionado.`,
        'alerts.syncInputWarn': `Non se puido sincronizar a entrada de ficheiros co arrastre.`,
        'controls.toggle.show': `Mostrar o panel de controis`,
        'controls.toggle.hide': `Agochar o panel de controis`,
        'controls.toggle.showButton': `Mostrar o panel de controis`,
        'export.notice.pngSingle': `Xerarase unha única imaxe PNG apilando as {pages} páxinas (ancho máximo {width}px e alto limitado a {height}px para que a IA lea o contido). Pode tardar uns segundos.`,
        'defaults.document': `documento`,
        'defaults.documentPdf': `documento.pdf`,
      },
      eu: {
        'app.windowTitle': `PDF eta irudien anonimizatzailea — bezeroa`,
        'app.headerTitle': `PDF eta irudien anonimizatzailea`,
        'lang.label': `Hizkuntza`,
        'info.noticeButton': `Ohar garrantzitsua`,
        'drop.default': `Arrastatu PDF bat edo irudi bat edo egin klik irekitzeko`,
        'status.page': `Orria`,
        'controls.usage.title': `Argibideak`,
        'controls.usage.help': `<ol class="usageList"><li>Arratoia <strong>ezker botoiarekin</strong> arrastatu uneko orrian laukizuzen bat marrazteko.</li><li><strong>Eskuineko botoiarekin</strong> arrastatuz, laukizuzen bera <strong>PDFko orri guztietan kokapen berean</strong> marraztuko duzu.</li><li>Egin <strong>klik bikoitza</strong> laukizuzen baten gainean hura ezabatzeko.</li><li>Sakatu <strong>“Garbitu orri honetako laukizuzenak”</strong> botoia uneko orriko laukizuzen guztiak kentzeko.</li></ol>`,
        'controls.rect.title': `Laukizuzenaren konfigurazioa`,
        'controls.rect.stroke': `Ertzaren lodiera:`,
        'controls.rect.opacity': `Estalduraren opakutasuna:`,
        'controls.rect.colorTitle': `Maskararen kolorea`,
        'controls.rect.color.black': `Beltza`,
        'controls.rect.color.white': `Zuria`,
        'controls.rect.color.gray': `Grisa`,
        'controls.clearButton': `Garbitu orri honetako laukizuzenak`,
        'naming.legend': `Esportatutako fitxategiaren izena`,
        'naming.option.derived': `Izen bera + _anonim`,
        'naming.option.fixed': `anonim.pdf`,
        'export.button.default': `Esportatu anonimizatuta`,
        'export.button.withTarget': `Esportatu {target}`,
        'export.mode.pdf': `PDF formatua`,
        'export.mode.zip': `PNG bat orri bakoitzeko duen ZIPa`,
        'export.mode.pngSingle': `PNG orri guztiekin`,
        'export.mode.pngImage': `PNG irudi anonimizatua`,
        'export.selector.label': `Esportazio-formatua`,
        'details.security.title': `Anonimizazioaren segurtasun-oharrak`,
        'details.security.item1': `Esportazioak irudiz osatutako PDFa sortzen du (rasterizatua). Jatorrizko testua desagertu egiten da: ez da hauta daitekeena ezta testu gisa ateragarria ere.`,
        'details.security.item2': `Egokia da ikasleen lanetako izen propioak ezkutatzeko, fitxategia handiagoa eta irisgarritasuna txikiagoa izatearen truke.`,
        'details.security.item3': `Erabilera erabat lokala da zure nabigatzailean.`,
        'details.credits.title': `Kredituak eta laguntza`,
        'details.credits.contact': `Zalantzak edo iradokizunak? Sakatu botoi berdea <a href="https://github.com/jjdeharo/anonim-pdf/issues" style="color:inherit; text-decoration:underline;">New issue</a> GitHuben.`,
        'details.credits.owner': `PDF eta irudien anonimizatzailea · © 2025 <a href="https://bilateria.es" style="color:inherit; text-decoration:underline;">Juan José de Haro</a> · Baliabidea: <a href="https://github.com/jjdeharo/anonim-pdf" style="color:inherit; text-decoration:underline;">github.com/jjdeharo/anonim-pdf</a>`,
        'details.credits.license': `<a href="./LICENSE.txt" style="color:inherit; text-decoration:underline;">Kodearen lizentzia: AGPL v3</a>`,
        'viewer.zoom.label': `Zooma:`,
        'viewer.zoom.inputLabel': `Zoomaren ehunekoa`,
        'viewer.zoom.fit': `Doitu zabalera`,
        'viewer.search.label': `Bilatu dokumentuan`,
        'viewer.search.placeholder': `Testua bilatu…`,
        'viewer.search.clearLabel': `Garbitu bilaketa`,
        'viewer.search.matchOne': `1 bat-etortze`,
        'viewer.search.matches': `{matches} bat-etortze`,
        'viewer.search.noResults': `Ez da bat datorrenik aurkitu`,
        'viewer.search.searching': `Bilatzen…`,
        'viewer.search.disabled': `PDF dokumentuentzat soilik erabilgarri`,
        'viewer.search.prevLabel': `Aurreko bat-etortzea`,
        'viewer.search.nextLabel': `Hurrengo bat-etortzea`,
        'viewer.search.indexed': `{current}/{total} bat-etortze`,
        'modal.close': `Itxi oharra`,
        'modal.title': `Ohar garrantzitsua`,
        'modal.body1': `Aplikazio honek tresnak eskaintzen ditu erabiltzaileak PDF edo irudi bat anonimizatu ahal izateko, ikasleen identifikazio datuak eskuz ezkutatzeko aukera emanez dokumentu berri bat sortu aurretik. Horrela, fitxategiak adimen artifizialeko tresnetan erabil daitezke informazio pertsonala agerian utzi gabe.`,
        'modal.body2': `Adimen artifizialak lagungarri izan daiteke analisi partzialak lortzeko, ereduak detektatzeko edo ikasleen lanen inguruko ikuspegi berriak emateko. <strong>Ez da nahastu behar bere erabilera irakasle-lanarekin</strong>: AAk ez du ebaluatzen, ez du zuzentzen eta ezin du hezkuntza-erantzukizuna bere gain hartu.`,
        'modal.body3': `<strong>Ebaluazioa, irizpide pedagogikoa eta ikasleen kalifikazioa beti irakasleen esku dago.</strong> AAk hausnarketa osatu dezake, baina inoiz ez du ordezkatuko irakaslearen profesionaltasuna eta azken erabakia.`,
        'alerts.pdfjsMissing': `Ezin izan da pdf.js kargatu. Egiaztatu konexioa edo blokeatzaileak. "pdfjsLib" erakusteko legacy build-era aldatu naiz.`,
        'alerts.pdfjsWorkerWarning': `Errorea pdf.js worker-a konfiguratzean; worker-rik gabeko modua erabiliko da.`,
        'alerts.exportError': `Errorea gertatu da dokumentua anonimizatuta esportatzean.`,
        'alerts.exportErrorLog': `Errorea esportazioan.`,
        'alerts.jsPdfMissing': `Ezin izan da jsPDF liburutegia kargatu.`,
        'alerts.jsZipMissing': `Ezin izan da JSZip liburutegia kargatu.`,
        'alerts.pngScaleNotice': `PNG bakarrak bereizmen txikiagoa izango du dokumentua luzea delako. Egiaztatu emaitza irakurgarria dela.`,
        'alerts.singlePngFail': `Ezin izan da PNG bakarra anonimizatua sortu.`,
        'alerts.imagePngFail': `Ezin izan da irudi anonimizatua sortu.`,
        'alerts.invalidFileType': `Hautatu PDF edo irudi fitxategi bat (PNG, JPG, WEBP…).`,
        'alerts.fileReadFailed': `Ezin izan da fitxategia irakurri. Saiatu beste PDF batekin.`,
        'alerts.pdfOpenError': `Ezin izan da PDFa ireki: {error}`,
        'alerts.imageOpenError': `Ezin izan da irudia ireki. Saiatu beste fitxategi batekin.`,
        'alerts.imageGenericError': `Ezin izan da irudia ireki.`,
        'alerts.imageSizeUnknown': `Ezin izan da irudiaren tamaina zehaztu.`,
        'alerts.pdfLoadErrorLog': `Errorea PDFa kargatzean`,
        'alerts.imageLoadErrorLog': `Ezin izan da hautatutako irudia kargatu.`,
        'alerts.fileReadErrorLog': `Ezin izan da arrastatutako/hautatutako fitxategia irakurri.`,
        'alerts.syncInputWarn': `Ezin izan da fitxategi-sarrera arrastaketarekin sinkronizatu.`,
        'controls.toggle.show': `Erakutsi kontrol-panela`,
        'controls.toggle.hide': `Ezkutatu kontrol-panela`,
        'controls.toggle.showButton': `Erakutsi kontrol-panela`,
        'export.notice.pngSingle': `PNG irudi bakarra sortuko da {pages} orriak pilatuz (gehienezko zabalera {width}px eta altuera {height}px, AAk edukia irakur dezan). Segundo batzuk behar izan ditzake.`,
        'defaults.document': `dokumentua`,
        'defaults.documentPdf': `dokumentua.pdf`,
      },
      en: {
        'app.windowTitle': `PDF & Image Anonymizer — client`,
        'app.headerTitle': `PDF & Image Anonymizer`,
        'lang.label': `Language`,
        'info.noticeButton': `Important notice`,
        'drop.default': `Drop a PDF or image or click to open`,
        'status.page': `Page`,
        'controls.usage.title': `Instructions`,
        'controls.usage.help': `<ol class="usageList"><li>Drag with the <strong>left mouse button</strong> to draw a rectangle on the current page.</li><li>Drag with the <strong>right button</strong> to draw the same rectangle in the <strong>same position on every page</strong> of the PDF.</li><li>Double-click a rectangle to delete it.</li><li>Press the <strong>“Clear rectangles on this page”</strong> button to remove all rectangles from the current page.</li></ol>`,
        'controls.rect.title': `Rectangle settings`,
        'controls.rect.stroke': `Border thickness:`,
        'controls.rect.opacity': `Mask opacity:`,
        'controls.rect.colorTitle': `Mask color`,
        'controls.rect.color.black': `Black`,
        'controls.rect.color.white': `White`,
        'controls.rect.color.gray': `Gray`,
        'controls.clearButton': `Clear rectangles on this page`,
        'naming.legend': `Exported file name`,
        'naming.option.derived': `Same name + _anonim`,
        'naming.option.fixed': `anonim.pdf`,
        'export.button.default': `Export anonymized`,
        'export.button.withTarget': `Export {target}`,
        'export.mode.pdf': `PDF format`,
        'export.mode.zip': `ZIP with one PNG per page`,
        'export.mode.pngSingle': `PNG with every page`,
        'export.mode.pngImage': `Anonymized PNG image`,
        'export.selector.label': `Export format`,
        'details.security.title': `Anonymization safety notes`,
        'details.security.item1': `Exporting creates an image-based (rasterized) PDF. The original text disappears: it is no longer selectable or extractable.`,
        'details.security.item2': `Ideal for hiding pupil names in submitted work, at the cost of larger files and reduced accessibility.`,
        'details.security.item3': `Everything runs locally in your browser.`,
        'details.credits.title': `Credits & support`,
        'details.credits.contact': `Questions or suggestions? Click the green <a href="https://github.com/jjdeharo/anonim-pdf/issues" style="color:inherit; text-decoration:underline;">New issue</a> button on GitHub.`,
        'details.credits.owner': `PDF & Image Anonymizer · © 2025 <a href="https://bilateria.es" style="color:inherit; text-decoration:underline;">Juan José de Haro</a> · Resource: <a href="https://github.com/jjdeharo/anonim-pdf" style="color:inherit; text-decoration:underline;">github.com/jjdeharo/anonim-pdf</a>`,
        'details.credits.license': `<a href="./LICENSE.txt" style="color:inherit; text-decoration:underline;">Code license: AGPL v3</a>`,
        'viewer.zoom.label': `Zoom:`,
        'viewer.zoom.inputLabel': `Zoom percentage`,
        'viewer.zoom.fit': `Fit width`,
        'viewer.search.label': `Search the document`,
        'viewer.search.placeholder': `Search text…`,
        'viewer.search.clearLabel': `Clear search`,
        'viewer.search.matchOne': `1 match`,
        'viewer.search.matches': `{matches} matches`,
        'viewer.search.noResults': `No matches`,
        'viewer.search.searching': `Searching…`,
        'viewer.search.disabled': `Available for PDF documents only`,
        'viewer.search.prevLabel': `Previous match`,
        'viewer.search.nextLabel': `Next match`,
        'viewer.search.indexed': `{current} of {total} matches`,
        'modal.close': `Close notice`,
        'modal.title': `Important notice`,
        'modal.body1': `This application provides tools so the user can anonymize a PDF or an image, allowing them to manually hide students' identifying data before generating a new document. This way, the files can be used with artificial intelligence tools without exposing personal information.`,
        'modal.body2': `Artificial intelligence can help obtain partial analyses, detect patterns or add new perspectives to students' work. <strong>It must not be confused with the teacher's role</strong>: AI does not grade, does not correct and cannot assume educational responsibility.`,
        'modal.body3': `<strong>Assessment, pedagogical judgement and grading always belong to the teaching staff.</strong> AI can support reflection, but never replace professional criteria or the teacher's final decision.`,
        'alerts.pdfjsMissing': `pdf.js could not be loaded. Check your connection or blockers. Switched to the legacy build to expose "pdfjsLib".`,
        'alerts.pdfjsWorkerWarning': `Failed to configure the pdf.js worker; running in workerless mode.`,
        'alerts.exportError': `An error occurred while exporting the anonymized document.`,
        'alerts.exportErrorLog': `Error during export.`,
        'alerts.jsPdfMissing': `The jsPDF library could not be loaded.`,
        'alerts.jsZipMissing': `The JSZip library could not be loaded.`,
        'alerts.pngScaleNotice': `The single PNG will be generated at a lower resolution because of the document length. Please check that the result is readable.`,
        'alerts.singlePngFail': `The single anonymized image could not be generated.`,
        'alerts.imagePngFail': `The anonymized image could not be generated.`,
        'alerts.invalidFileType': `Select a PDF or an image file (PNG, JPG, WEBP…).`,
        'alerts.fileReadFailed': `The file could not be read. Try another PDF.`,
        'alerts.pdfOpenError': `The PDF could not be opened: {error}`,
        'alerts.imageOpenError': `The image could not be opened. Try another file.`,
        'alerts.imageGenericError': `The image could not be opened.`,
        'alerts.imageSizeUnknown': `The image dimensions could not be determined.`,
        'alerts.pdfLoadErrorLog': `Error loading PDF`,
        'alerts.imageLoadErrorLog': `Could not load the selected image.`,
        'alerts.fileReadErrorLog': `Could not read the dropped/selected file.`,
        'alerts.syncInputWarn': `Could not sync the file input with the drop action.`,
        'controls.toggle.show': `Show control panel`,
        'controls.toggle.hide': `Hide control panel`,
        'controls.toggle.showButton': `Show control panel`,
        'export.notice.pngSingle': `Generates a single PNG stacking {pages} pages (maximum width {width}px and height capped at {height}px so AI can read the content). It may take a few seconds.`,
        'defaults.document': `document`,
        'defaults.documentPdf': `document.pdf`,
      },
    };

    let currentLocale = detectInitialLocale();

    const havePdfjs = typeof window.pdfjsLib !== 'undefined';
    if (!havePdfjs) {
      alert(t('alerts.pdfjsMissing'));
      return;
    }

    const WORKER_SRC = './vendor/pdfjs/pdf.worker.v216.min.js';
    try {
      pdfjsLib.GlobalWorkerOptions.workerSrc = WORKER_SRC;
    } catch (err) {
      console.warn(t('alerts.pdfjsWorkerWarning'), err);
      pdfjsLib.disableWorker = true;
    }

    const viewerContainer = document.getElementById('viewerContainer');
    const pagesContainer = document.getElementById('pagesContainer');
    const fileDrop = document.getElementById('fileDrop');
    const fileDropText = fileDrop.querySelector('span');
    const fileInput = document.getElementById('file');
    const main = document.querySelector('main');
    const controlsPanel = document.querySelector('.panelControls');
    const viewerPanel = document.querySelector('.panelViewer');
    const headerEl = document.querySelector('header');
    const pageNumEl = document.getElementById('pageNum');
    const pageCountEl = document.getElementById('pageCount');
    const btnExport = document.getElementById('export');
    const btnClearRects = document.getElementById('btnClearRects');
    const exportModeEl = document.getElementById('exportMode');
    const exportNoticeEl = document.getElementById('exportNotice');
    const downloadLink = document.getElementById('dlLink');
    const opacityEl = document.getElementById('opacity');
    const strokeWEl = document.getElementById('strokeW');
    const maskColorEl = document.getElementById('maskColor');
    const namingRadios = document.querySelectorAll('input[name="namingOption"]');
    const zoomOutBtn = document.getElementById('zoomOut');
    const zoomInBtn = document.getElementById('zoomIn');
    const zoomFitBtn = document.getElementById('zoomFit');
    const zoomDisplay = document.getElementById('zoomDisplay');
    const toggleControlsBtn = document.getElementById('toggleControls');
    const showControlsBtn = document.getElementById('showControls');
    const profModal = document.getElementById('profModal');
    const closeProfModalBtn = document.getElementById('closeProfModal');
    const openProfModalBtn = document.getElementById('openProfModal');
    const languageSelect = document.getElementById('languageSelect');
    const searchForm = document.getElementById('searchForm');
    const searchInput = document.getElementById('searchInput');
    const searchPrevBtn = document.getElementById('searchPrev');
    const searchNextBtn = document.getElementById('searchNext');
    const searchClearBtn = document.getElementById('searchClear');
    const searchStatusEl = document.getElementById('searchStatus');
    let lastFocusBeforeModal = null;

    let pdfDoc = null;
    let imageDoc = null;
    let docType = null;
    let scale = 1;
    let rectsByPage = {};
    let currentFileName = getDefaultDocumentName('.pdf');
    let namingStrategy = 'derived';
    let fitScale = 1;
    let basePageWidth = 0;
    let zoomFactor = 1;
    let resizeTimeout = null;
    const MIN_ZOOM = 0.6;
    const MAX_ZOOM = 3;
    const ZOOM_STEP = 0.2;
    const EXPORT_RENDER_SCALE = 2;
    const EXPORT_IMAGE_QUALITY = 0.92;
    const ZOOM_KEY = 'anonim-pdf-zoom';
    const CONTROLS_HIDDEN_KEY = 'anonim-pdf-controls-hidden';
    const EXPORT_MODE_KEY = 'anonim-pdf-export-mode';
    const SUPPORTED_IMAGE_REGEX = /\.(png|jpe?g|gif|bmp|webp|tiff?)$/i;
    const SINGLE_IMAGE_TARGET_WIDTH = 2048;
    const SINGLE_IMAGE_MAX_HEIGHT = 16384;
    const SINGLE_IMAGE_MAX_SCALE = 4.5;
    const SINGLE_IMAGE_MIN_SCALE = 1.6;
    const SINGLE_IMAGE_PAGE_GAP = 24;
    const SINGLE_IMAGE_CANVAS_LIMIT = 32760;
    const SINGLE_IMAGE_BACKGROUND = '#ffffff';
    const SEARCH_DEBOUNCE_MS = 220;
    const SEARCH_MIN_CHARS = 2;
    const SEARCH_HIGHLIGHT_FILL = 'rgba(253, 230, 138, 0.45)';
    const SEARCH_ACTIVE_STROKE = 'rgba(234, 179, 8, 0.9)';
    const SEARCH_DIACRITIC_REGEX = /[\u0300-\u036f]/g;
    let activePage = 1;
    let pageCount = 0;
    const pageViews = new Map();
    const pageStates = new Map();
    let searchTerm = '';
    let searchMatchesByPage = new Map();
    let searchMatchesOrdered = [];
    let activeMatchIndex = -1;
    let searchDebounceId = null;
    let searchRequestId = 0;

    const observer = 'IntersectionObserver' in window
      ? new IntersectionObserver((entries) => {
          let nextPage = activePage;
          let maxRatio = 0;
          for (const entry of entries) {
            if (entry.isIntersecting && entry.intersectionRatio > maxRatio) {
              nextPage = Number(entry.target.dataset.page);
              maxRatio = entry.intersectionRatio;
            }
          }
          if (nextPage !== activePage && pageViews.has(nextPage)) {
            setActivePage(nextPage);
          }
        }, { root: viewerContainer, threshold: [0.2, 0.45, 0.7] })
      : null;

    applyLocale(currentLocale, { skipPersist: true, initial: true });
    setFileDropStatus(getDefaultDropText(), false);
    resetExportControls();

    const storedControlsHidden = localStorage.getItem(CONTROLS_HIDDEN_KEY) === 'true';
    setControlsHidden(storedControlsHidden);
    syncViewerHeight();

    function persistControlsHidden(hidden) {
      localStorage.setItem(CONTROLS_HIDDEN_KEY, hidden ? 'true' : 'false');
    }

    toggleControlsBtn?.addEventListener('click', () => {
      const nextHidden = !document.body.classList.contains('controlsHidden');
      setControlsHidden(nextHidden);
      persistControlsHidden(nextHidden);
    });

    showControlsBtn?.addEventListener('click', () => {
      setControlsHidden(false);
      persistControlsHidden(false);
      toggleControlsBtn?.focus({ preventScroll: true });
    });

    openProfModalBtn?.addEventListener('click', () => openProfModal());
    closeProfModalBtn?.addEventListener('click', () => closeProfModal());
    profModal?.addEventListener('click', (event) => {
      if (event.target === profModal) {
        closeProfModal();
      }
    });
    document.addEventListener('keydown', (event) => {
      if (event.key === 'Escape' && profModal?.classList.contains('active')) {
        closeProfModal();
      }
    });

    fileDrop.addEventListener('click', () => fileInput.click());
    fileDrop.addEventListener('dragenter', (e) => {
      e.preventDefault();
      fileDrop.classList.add('dragging');
    });
    fileDrop.addEventListener('dragover', (e) => {
      e.preventDefault();
      e.dataTransfer.dropEffect = 'copy';
      fileDrop.classList.add('dragging');
    });
    fileDrop.addEventListener('dragleave', (e) => {
      const next = e.relatedTarget;
      if (!next || !fileDrop.contains(next)) {
        fileDrop.classList.remove('dragging');
      }
    });
    fileDrop.addEventListener('drop', async (e) => {
      e.preventDefault();
      fileDrop.classList.remove('dragging');
      const files = e.dataTransfer?.files;
      if (!files || !files.length) return;
      const file = files[0];
      if (!await openDocument(file)) return;
      try {
        const dt = new DataTransfer();
        dt.items.add(file);
        fileInput.files = dt.files;
      } catch (err) {
        console.warn(t('alerts.syncInputWarn'), err);
      }
    });

    fileInput.addEventListener('change', async (e) => {
      const file = e.target.files[0];
      if (!file) return;
      await openDocument(file);
      e.target.value = '';
    });

    exportModeEl.addEventListener('change', () => {
      updateExportButtonLabel();
      if (docType === 'pdf') {
        localStorage.setItem(EXPORT_MODE_KEY, exportModeEl.value);
      }
      updateExportNotice();
    });

    btnClearRects.addEventListener('click', () => {
      if (!docType) return;
      rectsByPage[activePage] = [];
      drawOverlay(activePage);
      updateClearButtonState();
    });

    maskColorEl.addEventListener('change', redrawAllOverlays);
    opacityEl.addEventListener('change', redrawAllOverlays);
    strokeWEl.addEventListener('change', redrawAllOverlays);

    const NAMING_KEY = 'anonim-pdf-naming';
    const storedNaming = (localStorage.getItem(NAMING_KEY) || '').toLowerCase();
    if (storedNaming === 'fixed' || storedNaming === 'derived') {
      namingStrategy = storedNaming;
    }
    namingRadios.forEach((radio) => {
      radio.checked = radio.value === namingStrategy;
      radio.addEventListener('change', () => {
        if (radio.checked) {
          namingStrategy = radio.value === 'fixed' ? 'fixed' : 'derived';
          localStorage.setItem(NAMING_KEY, namingStrategy);
        }
      });
    });

    languageSelect?.addEventListener('change', (event) => {
      const nextLocale = event.target.value;
      applyLocale(nextLocale);
    });

    searchForm?.addEventListener('submit', (event) => {
      event.preventDefault();
      if (docType !== 'pdf') return;
      triggerSearchNow();
    });

    searchInput?.addEventListener('input', () => {
      const value = searchInput.value || '';
      scheduleSearch(value);
      updateSearchClearButton();
    });

    searchInput?.addEventListener('keydown', (event) => {
      if (event.key === 'Escape' && searchInput.value) {
        searchInput.value = '';
        scheduleSearch('');
        updateSearchClearButton();
        event.stopPropagation();
      }
    });

    searchClearBtn?.addEventListener('click', () => {
      if (!searchInput) return;
      searchInput.value = '';
      scheduleSearch('');
      searchInput.focus({ preventScroll: true });
      updateSearchClearButton();
    });

    searchPrevBtn?.addEventListener('click', () => {
      goToRelativeMatch(-1);
    });

    searchNextBtn?.addEventListener('click', () => {
      goToRelativeMatch(1);
    });

    const storedZoom = parseFloat(localStorage.getItem(ZOOM_KEY) || '');
    if (!Number.isNaN(storedZoom)) {
      zoomFactor = clamp(storedZoom, MIN_ZOOM, MAX_ZOOM);
    }
    setZoomControlsEnabled(false);
    updateZoomDisplay();
    setSearchControlsEnabled(false);
    updateSearchStatus();

    zoomInBtn.addEventListener('click', () => {
      setZoomFactor(zoomFactor + ZOOM_STEP).catch((err) => console.error(err));
    });
    zoomOutBtn.addEventListener('click', () => {
      setZoomFactor(zoomFactor - ZOOM_STEP).catch((err) => console.error(err));
    });
    zoomFitBtn.addEventListener('click', () => {
      setZoomFactor(1).catch((err) => console.error(err));
    });
    if (zoomDisplay) {
      zoomDisplay.addEventListener('focus', () => {
        zoomDisplay.select();
      });
      zoomDisplay.addEventListener('keydown', (event) => {
        if (event.key === 'Enter') {
          event.preventDefault();
          applyZoomFromInput(zoomDisplay.value);
        } else if (event.key === 'Escape') {
          event.preventDefault();
          updateZoomDisplay();
          zoomDisplay.blur();
        }
      });
      zoomDisplay.addEventListener('blur', () => {
        if (zoomDisplay.disabled) return;
        applyZoomFromInput(zoomDisplay.value);
      });
    }

    btnExport.addEventListener('click', async () => {
      if (btnExport.disabled || !docType) return;
      try {
        if (docType === 'pdf') {
          const mode = exportModeEl.value;
          if (mode === 'zip') {
            await exportPdfAsZip();
          } else if (mode === 'png-single') {
            await exportPdfAsSingleImage();
          } else {
            await exportPdfAsPdf();
          }
        } else if (docType === 'image') {
          await exportImageAsPng();
        }
      } catch (err) {
        console.error(t('alerts.exportErrorLog'), err);
        alert(t('alerts.exportError'));
      }
    });

    function setSearchControlsEnabled(enabled) {
      if (searchInput) {
        searchInput.disabled = !enabled;
      }
      if (searchPrevBtn) {
        searchPrevBtn.disabled = true;
      }
      if (searchNextBtn) {
        searchNextBtn.disabled = true;
      }
      updateSearchClearButton();
      if (enabled) {
        updateSearchNavButtons();
      }
    }

    function updateSearchClearButton() {
      if (!searchClearBtn) return;
      if (!searchInput || searchInput.disabled) {
        searchClearBtn.disabled = true;
        return;
      }
      searchClearBtn.disabled = searchInput.value.trim().length === 0;
    }

    function updateSearchNavButtons() {
      const hasMatches = docType === 'pdf' && searchTerm.length >= SEARCH_MIN_CHARS && searchMatchesOrdered.length > 0;
      if (searchPrevBtn) {
        searchPrevBtn.disabled = !hasMatches;
      }
      if (searchNextBtn) {
        searchNextBtn.disabled = !hasMatches;
      }
    }

    function goToRelativeMatch(step) {
      if (!Number.isInteger(step) || searchMatchesOrdered.length === 0) return;
      const total = searchMatchesOrdered.length;
      if (activeMatchIndex < 0) {
        focusMatch(step > 0 ? 0 : total - 1);
        return;
      }
      const nextIndex = ((activeMatchIndex + step) % total + total) % total;
      focusMatch(nextIndex);
    }

    function focusMatch(index, { behavior = 'smooth' } = {}) {
      if (searchMatchesOrdered.length === 0) return;
      const total = searchMatchesOrdered.length;
      const normalized = ((index % total) + total) % total;
      activeMatchIndex = normalized;
      const match = searchMatchesOrdered[normalized];
      if (!match) return;
      setActivePage(match.pageNumber);
      scrollToMatch(match, behavior);
      redrawAllOverlays();
      updateSearchStatus();
      updateSearchNavButtons();
    }

    function scrollToMatch(match, behavior = 'smooth') {
      if (!viewerContainer) return;
      const view = pageViews.get(match.pageNumber);
      if (!view) return;
      const { wrapper } = view;
      const scaledY = match.rect.y * scale;
      const scaledH = match.rect.h * scale;
      const target = wrapper.offsetTop + scaledY - (viewerContainer.clientHeight / 2) + (scaledH / 2);
      const top = Math.max(target, 0);
      const scrollBehavior = behavior === 'instant' ? 'auto' : behavior;
      const canScrollViewer = (viewerContainer.scrollHeight - viewerContainer.clientHeight) > 2;

      if (canScrollViewer) {
        if (typeof viewerContainer.scrollTo === 'function') {
          viewerContainer.scrollTo({ top, behavior: scrollBehavior });
        } else {
          viewerContainer.scrollTop = top;
        }
        return;
      }

      // Fallback for layouts where the body handles scrolling instead of the viewer container.
      const viewportHeight = window.innerHeight || document.documentElement.clientHeight || viewerContainer.clientHeight || 0;
      const headerHeight = headerEl?.getBoundingClientRect().height || 0;
      const effectiveViewport = Math.max(viewportHeight - headerHeight, 120);
      const wrapperRect = wrapper.getBoundingClientRect();
      const pageScrollY = window.scrollY ?? window.pageYOffset ?? document.documentElement.scrollTop ?? 0;
      const absoluteTop = pageScrollY + wrapperRect.top + scaledY;
      const desiredTop = Math.max(absoluteTop - (effectiveViewport / 2) + (scaledH / 2) - headerHeight, 0);
      if (typeof window.scrollTo === 'function') {
        window.scrollTo({ top: desiredTop, behavior: scrollBehavior });
      } else {
        document.documentElement.scrollTop = desiredTop;
        document.body.scrollTop = desiredTop;
      }
    }

    function scheduleSearch(rawValue) {
      const value = (rawValue || '').trim();
      searchTerm = value;
      if (searchDebounceId) {
        clearTimeout(searchDebounceId);
        searchDebounceId = null;
      }
      if (!value) {
        clearSearchHighlights({ keepTerm: true });
        updateSearchStatus();
        updateSearchNavButtons();
        updateSearchClearButton();
        return;
      }
      if (docType !== 'pdf') {
        clearSearchHighlights({ keepTerm: true });
        updateSearchStatus();
        updateSearchNavButtons();
        updateSearchClearButton();
        return;
      }
      if (value.length < SEARCH_MIN_CHARS) {
        clearSearchHighlights({ keepTerm: true });
        updateSearchStatus();
        updateSearchNavButtons();
        updateSearchClearButton();
        return;
      }
      searchMatchesByPage = new Map();
      searchMatchesOrdered = [];
      activeMatchIndex = -1;
      redrawAllOverlays();
      setSearchStatusSearching();
      updateSearchNavButtons();
      const requestId = ++searchRequestId;
      searchDebounceId = setTimeout(() => {
        searchDebounceId = null;
        performSearch(value, requestId).catch((err) => console.error(err));
      }, SEARCH_DEBOUNCE_MS);
    }

    function triggerSearchNow() {
      if (!searchInput) return;
      const value = (searchInput.value || '').trim();
      searchTerm = value;
      if (!value) {
        scheduleSearch('');
        return;
      }
      if (docType !== 'pdf' || value.length < SEARCH_MIN_CHARS) {
        scheduleSearch(value);
        return;
      }
      if (searchDebounceId) {
        clearTimeout(searchDebounceId);
        searchDebounceId = null;
      }
      searchMatchesByPage = new Map();
      searchMatchesOrdered = [];
      activeMatchIndex = -1;
      redrawAllOverlays();
      setSearchStatusSearching();
      updateSearchNavButtons();
      const requestId = ++searchRequestId;
      performSearch(value, requestId).catch((err) => console.error(err));
    }

    function setSearchStatusSearching() {
      if (!searchStatusEl) return;
      if (!searchTerm || docType !== 'pdf' || searchTerm.length < SEARCH_MIN_CHARS) {
        return;
      }
      searchStatusEl.style.visibility = 'visible';
      searchStatusEl.textContent = t('viewer.search.searching');
      updateSearchNavButtons();
    }

    async function performSearch(term, requestId) {
      if (!pdfDoc || docType !== 'pdf') {
        return;
      }
      const normalizedTerm = normalizeSearchText(term);
      if (!normalizedTerm) {
        clearSearchHighlights({ keepTerm: true });
        updateSearchStatus();
        return;
      }
      const matchesMap = new Map();
      const ordered = [];
      for (let pageNumber = 1; pageNumber <= pageCount; pageNumber++) {
        const pageMatches = await findMatchesInPage(pageNumber, normalizedTerm);
        if (requestId !== searchRequestId) {
          return;
        }
        if (pageMatches.length) {
          matchesMap.set(pageNumber, pageMatches);
          for (const match of pageMatches) {
            match.index = ordered.length;
            ordered.push(match);
          }
        }
      }
      if (requestId !== searchRequestId) {
        return;
      }
      searchMatchesByPage = matchesMap;
      searchMatchesOrdered = ordered;
      if (!ordered.length) {
        activeMatchIndex = -1;
        updateSearchStatus(0);
        updateSearchNavButtons();
        redrawAllOverlays();
        return;
      }
      focusMatch(Math.min(activeMatchIndex >= 0 ? activeMatchIndex : 0, ordered.length - 1), { behavior: 'instant' });
    }

    async function findMatchesInPage(pageNumber, normalizedTerm) {
      if (!pdfDoc) return [];
      const page = await pdfDoc.getPage(pageNumber);
      const viewport = page.getViewport({ scale: 1 });
      const textContent = await page.getTextContent({ normalizeWhitespace: true });
      const items = textContent.items || [];
      const matches = [];
      for (const item of items) {
        const raw = item?.str;
        if (!raw) continue;
        const normalized = normalizeSearchText(raw);
        let index = normalized.indexOf(normalizedTerm);
        while (index !== -1) {
          const rect = buildHighlightRect(item, viewport, index, normalizedTerm.length);
          if (rect) {
            matches.push({ pageNumber, rect });
          }
          index = normalized.indexOf(normalizedTerm, index + normalizedTerm.length);
        }
      }
      if (typeof page.cleanup === 'function') {
        page.cleanup();
      }
      return matches;
    }

    function normalizeSearchText(text) {
      if (typeof text !== 'string') return '';
      return text.normalize('NFD').replace(SEARCH_DIACRITIC_REGEX, '').toLowerCase();
    }

    function clearSearchHighlights({ keepTerm = false, skipRedraw = false } = {}) {
      searchMatchesByPage = new Map();
      searchMatchesOrdered = [];
      activeMatchIndex = -1;
      if (!keepTerm) {
        searchTerm = '';
        if (searchInput) {
          searchInput.value = '';
        }
        if (searchClearBtn) {
          searchClearBtn.disabled = true;
        }
      }
      if (!skipRedraw) {
        redrawAllOverlays();
      }
      updateSearchNavButtons();
      updateSearchClearButton();
    }

    function countSearchMatches() {
      return searchMatchesOrdered.length;
    }

    function updateSearchStatus(totalMatchesOverride) {
      if (!searchStatusEl) return;
      updateSearchNavButtons();
      if (!searchTerm) {
        searchStatusEl.textContent = '';
        searchStatusEl.style.visibility = 'hidden';
        return;
      }
      if (docType !== 'pdf') {
        searchStatusEl.textContent = t('viewer.search.disabled');
        searchStatusEl.style.visibility = 'visible';
        return;
      }
      if (searchTerm.length < SEARCH_MIN_CHARS) {
        searchStatusEl.textContent = '';
        searchStatusEl.style.visibility = 'hidden';
        return;
      }
      const total = typeof totalMatchesOverride === 'number' ? totalMatchesOverride : countSearchMatches();
      searchStatusEl.style.visibility = 'visible';
      if (total === 0) {
        searchStatusEl.textContent = t('viewer.search.noResults');
      } else if (total === 1) {
        searchStatusEl.textContent = t('viewer.search.matchOne');
      } else {
        const current = activeMatchIndex >= 0 && activeMatchIndex < total
          ? formatNumber(activeMatchIndex + 1)
          : '';
        if (current) {
          searchStatusEl.textContent = t('viewer.search.indexed', { current, total: formatNumber(total) });
        } else {
          searchStatusEl.textContent = t('viewer.search.matches', { matches: formatNumber(total) });
        }
      }
    }

    function buildHighlightRect(item, viewport, startIndex, matchLength) {
      const str = item?.str || '';
      const totalChars = str.length || 1;
      const transform = pdfjsLib?.Util?.transform(viewport.transform, item.transform);
      if (!transform) return null;
      const e = transform[4];
      const f = transform[5];
      const d = transform[3];
      const baseHeight = Math.abs(d) || Math.abs(item.height) || 8;
      let totalWidth = Number.isFinite(item.width) ? item.width : 0;
      if (!totalWidth || totalWidth <= 0) {
        const scaleX = Math.hypot(transform[0], transform[1]);
        totalWidth = scaleX * totalChars;
      }
      let charWidth = totalWidth / Math.max(1, totalChars);
      if (!Number.isFinite(charWidth) || charWidth <= 0) {
        charWidth = Math.max(Math.abs(transform[0]), 1);
      }
      const startOffset = charWidth * Math.max(0, Math.min(startIndex, totalChars));
      const spanWidth = Math.max(charWidth * matchLength, charWidth * 0.6, 2);
      const x = e + startOffset;
      const top = d < 0 ? f + d : f;
      const maxWidth = viewport.width;
      const maxHeight = viewport.height;
      const clampedX = Math.min(Math.max(x, 0), maxWidth);
      const clampedY = Math.min(Math.max(top, 0), maxHeight);
      const clampedWidth = Math.min(Math.max(spanWidth, 2), maxWidth - clampedX);
      const clampedHeight = Math.min(Math.max(baseHeight, 6), maxHeight - clampedY);
      return {
        x: clampedX,
        y: clampedY,
        w: Math.max(clampedWidth, 0),
        h: Math.max(clampedHeight, 0),
      };
    }

    function getMaskSettings() {
      const mask = maskColorEl.value || '#000';
      const alpha = Math.max(0.1, Math.min(1, Number(opacityEl.value) || 1));
      return { mask, alpha };
    }

    function getRectScaleForExport(targetScale) {
      return scale > 0 ? targetScale / scale : targetScale;
    }

    async function exportPdfAsPdf() {
      if (!pdfDoc) return;
      const jspdfNs = window.jspdf;
      if (!jspdfNs || typeof jspdfNs.jsPDF !== 'function') {
        alert(t('alerts.jsPdfMissing'));
        return;
      }
      const { jsPDF } = jspdfNs;
      const { mask, alpha } = getMaskSettings();
      const totalPages = pdfDoc.numPages;
      let pdfOut = null;

      for (let p = 1; p <= totalPages; p++) {
        const page = await pdfDoc.getPage(p);
        const baseViewport = page.getViewport({ scale: 1 });
        const exportViewport = page.getViewport({ scale: EXPORT_RENDER_SCALE });

        const pageCanvas = document.createElement('canvas');
        pageCanvas.width = exportViewport.width;
        pageCanvas.height = exportViewport.height;
        const pctx = pageCanvas.getContext('2d');
        await page.render({ canvasContext: pctx, viewport: exportViewport }).promise;

        const rects = rectsByPage[p] || [];
        const rectScale = getRectScaleForExport(EXPORT_RENDER_SCALE);
        paintMaskRects(pctx, rects, mask, alpha, rectScale);

        const pageWidth = baseViewport.width;
        const pageHeight = baseViewport.height;
        const orientation = pageWidth >= pageHeight ? 'landscape' : 'portrait';

        if (!pdfOut) {
          pdfOut = new jsPDF({
            orientation,
            unit: 'pt',
            format: [pageWidth, pageHeight],
            compress: true,
          });
        } else {
          pdfOut.addPage([pageWidth, pageHeight], orientation);
          pdfOut.setPage(pdfOut.getNumberOfPages());
        }

        const img = pageCanvas.toDataURL('image/jpeg', EXPORT_IMAGE_QUALITY);
        pdfOut.addImage(img, 'JPEG', 0, 0, pageWidth, pageHeight, undefined, 'FAST');
      }

      if (!pdfOut) return;
      const blob = pdfOut.output('blob');
      triggerDownload(blob, buildAnonName(currentFileName, '.pdf'));
    }

    async function exportPdfAsZip() {
      if (!pdfDoc) return;
      const JSZipCtor = window.JSZip;
      if (typeof JSZipCtor !== 'function') {
        alert(t('alerts.jsZipMissing'));
        return;
      }
      const zip = new JSZipCtor();
      const { mask, alpha } = getMaskSettings();
      const totalPages = pdfDoc.numPages;
      const padding = String(totalPages).length;

      for (let p = 1; p <= totalPages; p++) {
        const page = await pdfDoc.getPage(p);
        const exportViewport = page.getViewport({ scale: EXPORT_RENDER_SCALE });
        const pageCanvas = document.createElement('canvas');
        pageCanvas.width = exportViewport.width;
        pageCanvas.height = exportViewport.height;
        const ctx = pageCanvas.getContext('2d');
        await page.render({ canvasContext: ctx, viewport: exportViewport }).promise;

        const rects = rectsByPage[p] || [];
        const rectScale = getRectScaleForExport(EXPORT_RENDER_SCALE);
        paintMaskRects(ctx, rects, mask, alpha, rectScale);

        const dataUrl = pageCanvas.toDataURL('image/png');
        const base64 = dataUrl.split(',')[1] || '';
        const fileName = `pagina-${String(p).padStart(padding, '0')}.png`;
        zip.file(fileName, base64, { base64: true });
      }

      const blob = await zip.generateAsync({ type: 'blob' });
      triggerDownload(blob, buildAnonName(currentFileName, '.zip'));
    }

    async function exportPdfAsSingleImage() {
      if (!pdfDoc) return;
      const totalPages = pdfDoc.numPages;
      if (totalPages === 0) return;
      const { mask, alpha } = getMaskSettings();

      const entries = [];
      let maxWidth = 0;
      let totalHeight = 0;
      for (let p = 1; p <= totalPages; p++) {
        const page = await pdfDoc.getPage(p);
        const viewport = page.getViewport({ scale: 1 });
        entries.push({ pageNumber: p, page, width: viewport.width, height: viewport.height });
        maxWidth = Math.max(maxWidth, viewport.width);
        totalHeight += viewport.height;
      }

      const gapTotal = SINGLE_IMAGE_PAGE_GAP * Math.max(0, totalPages - 1);
      const heightScale = (SINGLE_IMAGE_MAX_HEIGHT - gapTotal) / totalHeight;
      const heightLimitScale = (SINGLE_IMAGE_CANVAS_LIMIT - gapTotal) / totalHeight;
      const widthScale = SINGLE_IMAGE_TARGET_WIDTH / maxWidth;
      const widthLimitScale = SINGLE_IMAGE_CANVAS_LIMIT / maxWidth;
      const scales = [widthScale, SINGLE_IMAGE_MAX_SCALE, heightScale, heightLimitScale, widthLimitScale]
        .filter((value) => Number.isFinite(value) && value > 0);
      let scaleFactor = scales.length ? Math.min(...scales) : 1;
      if (!Number.isFinite(scaleFactor) || scaleFactor <= 0) {
        scaleFactor = 1;
      }
      const requestedMin = SINGLE_IMAGE_MIN_SCALE;
      let minScaleNotice = false;
      if (scaleFactor < requestedMin) {
        minScaleNotice = true;
      }

      let exportHeight = Math.floor(totalHeight * scaleFactor) + gapTotal;
      if (exportHeight > SINGLE_IMAGE_CANVAS_LIMIT) {
        const adjustedScale = (SINGLE_IMAGE_CANVAS_LIMIT - gapTotal) / totalHeight;
        if (Number.isFinite(adjustedScale) && adjustedScale > 0) {
          scaleFactor = adjustedScale;
          exportHeight = Math.floor(totalHeight * scaleFactor) + gapTotal;
        } else {
          exportHeight = SINGLE_IMAGE_CANVAS_LIMIT;
        }
      }

      if (minScaleNotice) {
        alert(t('alerts.pngScaleNotice'));
      }

      const canvas = document.createElement('canvas');
      const exportWidth = Math.max(1, Math.floor(maxWidth * scaleFactor));
      canvas.width = Math.max(1, Math.min(exportWidth, SINGLE_IMAGE_CANVAS_LIMIT));
      canvas.height = Math.max(1, Math.min(exportHeight, SINGLE_IMAGE_CANVAS_LIMIT));
      const ctx = canvas.getContext('2d');
      ctx.fillStyle = SINGLE_IMAGE_BACKGROUND;
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      let offsetY = 0;
      const rectScale = getRectScaleForExport(scaleFactor);
      for (let i = 0; i < entries.length; i++) {
        const { page, pageNumber, width, height } = entries[i];
        const viewport = page.getViewport({ scale: scaleFactor });
        const renderCanvas = document.createElement('canvas');
        renderCanvas.width = Math.max(1, Math.round(viewport.width));
        renderCanvas.height = Math.max(1, Math.round(viewport.height));
        const rctx = renderCanvas.getContext('2d');
        await page.render({ canvasContext: rctx, viewport }).promise;

        const rects = rectsByPage[pageNumber] || [];
        paintMaskRects(rctx, rects, mask, alpha, rectScale);

        ctx.drawImage(renderCanvas, 0, offsetY);
        offsetY += renderCanvas.height;
        if (i < entries.length - 1) {
          offsetY += SINGLE_IMAGE_PAGE_GAP;
        }
        page.cleanup?.();
        entries[i].page = null;
      }

      const blob = await canvasToBlob(canvas, 'image/png');
      if (!blob) {
        alert(t('alerts.singlePngFail'));
        return;
      }
      triggerDownload(blob, buildAnonName(currentFileName, '.png'));
    }

    async function exportImageAsPng() {
      if (!imageDoc) return;
      const { mask, alpha } = getMaskSettings();
      const canvas = document.createElement('canvas');
      canvas.width = imageDoc.width;
      canvas.height = imageDoc.height;
      const ctx = canvas.getContext('2d');
      ctx.drawImage(imageDoc.image, 0, 0, canvas.width, canvas.height);

      const rects = rectsByPage[1] || [];
      const rectScale = getRectScaleForExport(1);
      paintMaskRects(ctx, rects, mask, alpha, rectScale);

      const blob = await canvasToBlob(canvas, 'image/png');
      if (!blob) {
        alert(t('alerts.imagePngFail'));
        return;
      }
      triggerDownload(blob, buildAnonName(currentFileName, '.png'));
    }

    function canvasToBlob(canvas, type, quality) {
      return new Promise((resolve) => {
        canvas.toBlob(resolve, type, quality);
      });
    }

    function paintMaskRects(ctx, rects, color, alpha, rectScale) {
      if (!ctx || !Array.isArray(rects) || rects.length === 0) return;
      const factor = Number.isFinite(rectScale) && rectScale > 0 ? rectScale : 1;
      ctx.save();
      ctx.fillStyle = color;
      for (const rect of rects) {
        ctx.globalAlpha = alpha;
        ctx.fillRect(rect.x * factor, rect.y * factor, rect.w * factor, rect.h * factor);
      }
      ctx.restore();
    }

    function triggerDownload(blob, fileName) {
      if (!blob) return;
      const url = URL.createObjectURL(blob);
      downloadLink.href = url;
      downloadLink.download = fileName;
      downloadLink.click();
      downloadLink.style.display = 'none';
      setTimeout(() => URL.revokeObjectURL(url), 10_000);
    }

    function openProfModal() {
      if (!profModal) return;
      lastFocusBeforeModal = document.activeElement instanceof HTMLElement ? document.activeElement : null;
      profModal.classList.add('active');
      document.body.style.overflow = 'hidden';
      closeProfModalBtn?.focus({ preventScroll: true });
    }

    function closeProfModal() {
      if (!profModal) return;
      profModal.classList.remove('active');
      document.body.style.overflow = '';
      lastFocusBeforeModal?.focus?.({ preventScroll: true });
    }

    function setControlsHidden(hidden) {
      document.body.classList.toggle('controlsHidden', hidden);
      const showLabel = t('controls.toggle.show');
      const hideLabel = t('controls.toggle.hide');
      const showButtonLabel = t('controls.toggle.showButton');
      if (toggleControlsBtn) {
        const label = hidden ? showLabel : hideLabel;
        toggleControlsBtn.setAttribute('aria-pressed', hidden ? 'true' : 'false');
        toggleControlsBtn.setAttribute('aria-label', label);
        toggleControlsBtn.setAttribute('title', label);
      }
      if (showControlsBtn) {
        showControlsBtn.setAttribute('aria-pressed', hidden ? 'true' : 'false');
        showControlsBtn.setAttribute('aria-label', showButtonLabel);
        showControlsBtn.setAttribute('title', showButtonLabel);
      }
      syncViewerHeight();
    }

    function resetExportControls() {
      if (!exportModeEl) return;
      exportModeEl.innerHTML = '';
      exportModeEl.disabled = true;
      btnExport.disabled = true;
      btnExport.textContent = t('export.button.default');
      exportModeEl.value = '';
      exportModeEl.hidden = true;
      exportModeEl.style.display = 'none';
      exportModeEl.dataset.singleKey = '';
      clearExportNotice();
    }

    function setFileDropStatus(label, loaded) {
      fileDropText.textContent = label;
      if (loaded) {
        fileDrop.classList.add('hasFile');
      } else {
        fileDrop.classList.remove('hasFile');
      }
    }

    function configureExportForDoc(type) {
      if (!exportModeEl) return;
      exportModeEl.innerHTML = '';
      let defaultValue = '';
      let optionList = [];
      if (type === 'pdf') {
        optionList = [
          { value: 'pdf', key: 'export.mode.pdf' },
          { value: 'zip', key: 'export.mode.zip' }
        ];
        if (pageCount > 1) {
          optionList.push({ value: 'png-single', key: 'export.mode.pngSingle' });
        }
        const stored = localStorage.getItem(EXPORT_MODE_KEY);
        defaultValue = optionList.some((opt) => opt.value === stored) ? stored : 'pdf';
      } else {
        optionList = [{ value: 'png', key: 'export.mode.pngImage' }];
        defaultValue = 'png';
      }
      for (const opt of optionList) {
        const optionEl = document.createElement('option');
        optionEl.value = opt.value;
        optionEl.dataset.i18nKey = opt.key;
        optionEl.textContent = t(opt.key);
        exportModeEl.appendChild(optionEl);
      }
      const hasMultipleOptions = optionList.length > 1;
      btnExport.disabled = false;
      exportModeEl.value = defaultValue;
      exportModeEl.dataset.singleKey = hasMultipleOptions ? '' : (optionList[0]?.key || '');
      const showSelect = type === 'pdf' && hasMultipleOptions;
      exportModeEl.disabled = !showSelect;
      exportModeEl.hidden = !showSelect;
      exportModeEl.style.display = showSelect ? 'inline-block' : 'none';
      refreshExportModeLabels();
      updateExportButtonLabel();
      if (type !== 'pdf') {
        localStorage.removeItem(EXPORT_MODE_KEY);
      }
      updateExportNotice();
    }

    function updateExportButtonLabel() {
      let labelKey = '';
      if (exportModeEl.hidden || exportModeEl.options.length === 1) {
        labelKey = exportModeEl.dataset.singleKey || exportModeEl.options[0]?.dataset.i18nKey || '';
      } else {
        const selected = exportModeEl.options[exportModeEl.selectedIndex];
        labelKey = selected?.dataset.i18nKey || '';
      }
      const labelText = labelKey ? t(labelKey) : '';
      btnExport.textContent = labelText ? t('export.button.withTarget', { target: labelText }) : t('export.button.default');
    }

    function updateExportNotice(forceHide = false) {
      if (!exportNoticeEl) return;
      if (forceHide || !docType) {
        clearExportNotice();
        return;
      }
      if (docType === 'pdf' && pageCount > 1 && exportModeEl.value === 'png-single') {
        const widthText = formatNumber(SINGLE_IMAGE_TARGET_WIDTH);
        const heightText = formatNumber(SINGLE_IMAGE_MAX_HEIGHT);
        exportNoticeEl.textContent = t('export.notice.pngSingle', { pages: pageCount, width: widthText, height: heightText });
        exportNoticeEl.style.display = 'block';
      } else {
        clearExportNotice();
      }
    }

    function clearExportNotice() {
      if (!exportNoticeEl) return;
      exportNoticeEl.textContent = '';
      exportNoticeEl.style.display = 'none';
    }

    function syncViewerHeight() {
      if (!viewerContainer || !main) return;
      const isSingleColumn = typeof window.matchMedia === 'function'
        ? window.matchMedia('(max-width: 900px)').matches
        : (window.innerWidth || 0) <= 900;
      if (isSingleColumn) {
        viewerContainer.style.maxHeight = '';
        if (viewerPanel) {
          viewerPanel.style.maxHeight = '';
        }
        if (controlsPanel) {
          controlsPanel.style.maxHeight = '';
          controlsPanel.style.overflowY = '';
          controlsPanel.style.position = '';
          controlsPanel.style.top = '';
        }
        return;
      }

      const mainStyles = getComputedStyle(main);
      const verticalGap = parseFloat(mainStyles.rowGap || mainStyles.gap || '0') || 0;
      const paddingTop = parseFloat(mainStyles.paddingTop || '0') || 0;
      const paddingBottom = parseFloat(mainStyles.paddingBottom || '0') || 0;
      const headerHeight = headerEl?.getBoundingClientRect().height || 0;
      const viewportHeight = window.innerHeight || document.documentElement.clientHeight || 0;
      const available = viewportHeight - headerHeight - paddingTop - paddingBottom - verticalGap - 16;
      let target = Number.isFinite(available) && available > 0 ? Math.floor(available) : 420;
      if (!Number.isFinite(target) || target <= 0) {
        target = 420;
      } else if (target > 2000) {
        target = 2000;
      }

      viewerContainer.style.maxHeight = `${target}px`;
      if (viewerPanel) {
        viewerPanel.style.maxHeight = `${target}px`;
      }
      if (controlsPanel) {
        controlsPanel.style.maxHeight = `${target}px`;
        controlsPanel.style.overflowY = 'auto';
        const stickyOffset = headerHeight + paddingTop;
        controlsPanel.style.position = 'sticky';
        controlsPanel.style.top = `${Math.max(stickyOffset, paddingTop)}px`;
      }
    }

    function resetViewerState() {
      rectsByPage = {};
      pageViews.clear();
      pageStates.clear();
      observer?.disconnect();
      pagesContainer.innerHTML = '';
      activePage = 1;
      pageCount = 0;
      docType = null;
      pageNumEl.textContent = '-';
      pageCountEl.textContent = '-';
      btnClearRects.disabled = true;
      resetExportControls();
      setZoomControlsEnabled(false);
      setFileDropStatus(getDefaultDropText(), false);
      clearSearchHighlights({ keepTerm: true, skipRedraw: true });
      setSearchControlsEnabled(false);
      updateSearchStatus();
      syncViewerHeight();
    }

    async function openDocument(file) {
      if (!file) return false;
      const name = (file && file.name) ? file.name : getDefaultDocumentBase();
      const lowerName = name.toLowerCase();
      const type = (file.type || '').toLowerCase();
      const isPdf = type === 'application/pdf' || lowerName.endsWith('.pdf');
      const isImage = type.startsWith('image/') || SUPPORTED_IMAGE_REGEX.test(lowerName);

      if (!isPdf && !isImage) {
        alert(t('alerts.invalidFileType'));
        setFileDropStatus(getDefaultDropText(), false);
        return false;
      }

      if (isPdf) {
        let arrayBuf;
        try {
          arrayBuf = await file.arrayBuffer();
        } catch (err) {
          console.error(t('alerts.fileReadErrorLog'), err);
          alert(t('alerts.fileReadFailed'));
          setFileDropStatus(getDefaultDropText(), false);
          return false;
        }
        const loaded = await loadPdfFromArrayBuffer(arrayBuf, name);
        setFileDropStatus(loaded ? name : getDefaultDropText(), loaded);
        return loaded;
      }

      const loaded = await loadImageDocument(file);
      setFileDropStatus(loaded ? name : getDefaultDropText(), loaded);
      return loaded;
    }

    async function loadPdfFromArrayBuffer(arrayBuf, fileName = getDefaultDocumentName('.pdf')) {
      const targetName = forceExtension(sanitizeFileName(fileName), '.pdf');
      const loadingTask = pdfjsLib.getDocument({
        data: arrayBuf,
        cMapUrl: './vendor/pdfjs/cmaps/',
        cMapPacked: true,
        standardFontDataUrl: './vendor/pdfjs/standard_fonts/'
      });
      try {
        pdfDoc = await loadingTask.promise;
      } catch (err) {
        console.error(t('alerts.pdfLoadErrorLog'), err);
        const message = err && err.message ? err.message : String(err);
        alert(t('alerts.pdfOpenError', { error: message }));
        return false;
      }
      resetViewerState();

      currentFileName = targetName;

      docType = 'pdf';
      imageDoc = null;

      const firstPage = await pdfDoc.getPage(1);
      const baseViewport = firstPage.getViewport({ scale: 1 });
      basePageWidth = baseViewport.width;
      fitScale = computeScaleForWidth(basePageWidth);
      scale = fitScale * zoomFactor;

      pageCount = pdfDoc.numPages;

      await renderPage(1, firstPage);
      for (let p = 2; p <= pdfDoc.numPages; p++) {
        await renderPage(p);
      }

      pageCountEl.textContent = pdfDoc.numPages;
      setActivePage(1);
      updateClearButtonState();
      configureExportForDoc('pdf');
      setZoomControlsEnabled(true);
      updateZoomDisplay();
      setSearchControlsEnabled(true);
      if (searchInput) {
        if (searchInput.value.trim()) {
          scheduleSearch(searchInput.value);
        } else {
          updateSearchStatus();
        }
        updateSearchClearButton();
      } else {
        updateSearchStatus();
      }
      syncViewerHeight();
      return true;
    }

    async function loadImageDocument(file) {
      const fallbackExt = guessImageExtension(file);
      let objectUrl = '';
      let image;
      try {
        objectUrl = URL.createObjectURL(file);
        image = await loadImageElement(objectUrl);
      } catch (err) {
        console.error(t('alerts.imageLoadErrorLog'), err);
        alert(t('alerts.imageOpenError'));
        if (objectUrl) URL.revokeObjectURL(objectUrl);
        return false;
      }
      if (objectUrl) {
        URL.revokeObjectURL(objectUrl);
      }
      if (!image) {
        alert(t('alerts.imageGenericError'));
        return false;
      }
      const width = image.naturalWidth || image.width;
      const height = image.naturalHeight || image.height;
      if (!width || !height) {
        alert(t('alerts.imageSizeUnknown'));
        return false;
      }

      resetViewerState();

      currentFileName = ensureExtension(sanitizeFileName(file.name), fallbackExt);

      docType = 'image';
      pdfDoc = null;
      imageDoc = { image, width, height };
      basePageWidth = width;
      fitScale = computeScaleForWidth(basePageWidth);
      scale = fitScale * zoomFactor;
      pageCount = 1;

      await renderPage(1, imageDoc);
      pageCountEl.textContent = '1';
      setActivePage(1);
      updateClearButtonState();
      configureExportForDoc('image');
      setZoomControlsEnabled(true);
      updateZoomDisplay();
      clearSearchHighlights({ keepTerm: true });
      setSearchControlsEnabled(false);
      updateSearchStatus();
      syncViewerHeight();
      return true;
    }

    async function renderPage(pageNumber, pageInstance) {
      if (!docType) return;
      let view = pageViews.get(pageNumber);
      if (!view) {
        view = createPageView(pageNumber);
      }
      const { canvas, overlay, img, ctx, wrapper } = view;

      if (docType === 'pdf') {
        const page = pageInstance || await pdfDoc.getPage(pageNumber);
        const viewport = page.getViewport({ scale });
        const width = viewport.width;
        const height = viewport.height;
        canvas.width = width; canvas.height = height;
        overlay.width = width; overlay.height = height;
        img.width = width; img.height = height;
        img.style.width = overlay.style.width = width + 'px';
        img.style.height = overlay.style.height = height + 'px';
        wrapper.style.width = width + 'px';
        wrapper.style.height = height + 'px';
        await page.render({ canvasContext: ctx, viewport }).promise;
      } else if (docType === 'image' && imageDoc) {
        const width = imageDoc.width * scale;
        const height = imageDoc.height * scale;
        const canvasWidth = Math.max(1, Math.round(width));
        const canvasHeight = Math.max(1, Math.round(height));
        canvas.width = canvasWidth;
        canvas.height = canvasHeight;
        overlay.width = canvasWidth;
        overlay.height = canvasHeight;
        img.width = canvasWidth;
        img.height = canvasHeight;
        const displayWidth = canvasWidth + 'px';
        const displayHeight = canvasHeight + 'px';
        img.style.width = overlay.style.width = displayWidth;
        img.style.height = overlay.style.height = displayHeight;
        wrapper.style.width = displayWidth;
        wrapper.style.height = displayHeight;
        ctx.clearRect(0, 0, canvasWidth, canvasHeight);
        ctx.drawImage(imageDoc.image, 0, 0, canvasWidth, canvasHeight);
      }

      img.src = canvas.toDataURL('image/png');
      drawOverlay(pageNumber);
    }

    function createPageView(pageNumber) {
      const wrapper = document.createElement('div');
      wrapper.className = 'pageView';
      wrapper.dataset.page = String(pageNumber);

      const canvas = document.createElement('canvas');
      canvas.className = 'pdfPageCanvas';

      const img = document.createElement('img');
      img.className = 'pdfPageImage';
      img.draggable = false;

      const overlay = document.createElement('canvas');
      overlay.className = 'pdfOverlay';

      wrapper.append(img, overlay, canvas);
      pagesContainer.appendChild(wrapper);
      observer?.observe(wrapper);

      const view = {
        wrapper,
        canvas,
        img,
        overlay,
        ctx: canvas.getContext('2d'),
        octx: overlay.getContext('2d')
      };

      setupOverlayInteractions(pageNumber, view);
      pageViews.set(pageNumber, view);
      return view;
    }

    function setupOverlayInteractions(pageNumber, view) {
      const { overlay } = view;
      overlay.addEventListener('mousedown', (e) => {
        if (e.button !== 0 && e.button !== 2) return;
        e.preventDefault();
        const state = getPageState(pageNumber);
        const { x, y } = getMousePos(e, overlay);
        state.drawing = true;
        state.startX = x;
        state.startY = y;
        state.previewRect = null;
        state.button = e.button;
        state.applyAll = docType === 'pdf' && pageCount > 1 && e.button === 2;
        setActivePage(pageNumber);
      });

      overlay.addEventListener('mousemove', (e) => {
        const state = getPageState(pageNumber);
        if (!state.drawing) return;
        const { x, y } = getMousePos(e, overlay);
        state.previewRect = normalizeRect(state.startX, state.startY, x, y);
        drawOverlay(pageNumber);
      });

      const endDrawing = () => {
      const state = getPageState(pageNumber);
      if (!state.drawing) return;
      state.drawing = false;
      if (!rectsByPage[pageNumber]) rectsByPage[pageNumber] = [];
      const rect = state.previewRect;
      if (rect && rect.w > 4 && rect.h > 4) {
        rectsByPage[pageNumber].push({ ...rect });
        const applyAll = docType === 'pdf' && pageCount > 1 && state.applyAll;
        if (applyAll) {
          applyRectToAllPages(rect, pageNumber);
        }
      }
      state.previewRect = null;
      state.applyAll = false;
      state.button = 0;
      drawOverlay(pageNumber);
      updateClearButtonState();
    };

      overlay.addEventListener('mouseup', endDrawing);
      overlay.addEventListener('mouseleave', endDrawing);
      overlay.addEventListener('contextmenu', (e) => {
        e.preventDefault();
      });

      overlay.addEventListener('dblclick', (e) => {
        e.preventDefault();
        const rects = rectsByPage[pageNumber];
        if (!rects || rects.length === 0) return;
        const { x, y } = getMousePos(e, overlay);
        let removed = false;
        for (let i = rects.length - 1; i >= 0; i--) {
          const rect = rects[i];
          if (isPointInsideRect(x, y, rect)) {
            rects.splice(i, 1);
            removed = true;
            break;
          }
        }
        if (!removed) return;
        drawOverlay(pageNumber);
        updateClearButtonState();
      });
    }

    function getPageState(pageNumber) {
      if (!pageStates.has(pageNumber)) {
        pageStates.set(pageNumber, {
          drawing: false,
          startX: 0,
          startY: 0,
          previewRect: null,
          applyAll: false,
          button: 0
        });
      }
      return pageStates.get(pageNumber);
    }

    function drawOverlay(pageNumber) {
      const view = pageViews.get(pageNumber);
      if (!view) return;
      const { overlay, octx } = view;
      octx.clearRect(0, 0, overlay.width, overlay.height);
      if (docType === 'pdf') {
        const highlights = searchMatchesByPage.get(pageNumber) || [];
        const activeMatch = activeMatchIndex >= 0 ? searchMatchesOrdered[activeMatchIndex] : null;
        if (highlights.length) {
          octx.save();
          octx.fillStyle = SEARCH_HIGHLIGHT_FILL;
          for (const match of highlights) {
            const rect = match.rect;
            const scaledX = rect.x * scale;
            const scaledY = rect.y * scale;
            const scaledW = rect.w * scale;
            const scaledH = rect.h * scale;
            octx.fillRect(scaledX, scaledY, scaledW, scaledH);
            if (activeMatch === match) {
              octx.lineWidth = 2;
              octx.strokeStyle = SEARCH_ACTIVE_STROKE;
              octx.strokeRect(scaledX - 1, scaledY - 1, scaledW + 2, scaledH + 2);
            }
          }
          octx.restore();
        }
      }
      const mask = maskColorEl.value || '#000';
      const alpha = Math.max(0.1, Math.min(1, Number(opacityEl.value) || 1));
      const strokeW = Number(strokeWEl.value) || 2;
      const rects = rectsByPage[pageNumber] || [];
      const preview = pageStates.get(pageNumber)?.previewRect || null;

      octx.save();
      for (const rect of rects) paintRect(octx, rect, mask, alpha, strokeW);
      if (preview) paintRect(octx, preview, mask, alpha, strokeW);
      octx.restore();
    }

    function paintRect(ctx, rect, mask, alpha, strokeW) {
      ctx.globalAlpha = alpha;
      ctx.fillStyle = mask;
      ctx.fillRect(rect.x, rect.y, rect.w, rect.h);
      ctx.globalAlpha = 1;
      ctx.lineWidth = strokeW;
      ctx.strokeStyle = '#000';
      ctx.strokeRect(rect.x, rect.y, rect.w, rect.h);
    }

    function redrawAllOverlays() {
      for (const pageNumber of pageViews.keys()) {
        drawOverlay(pageNumber);
      }
    }

    function formatZoomPercent(factor) {
      return (factor * 100).toFixed(2).replace(/\.?0+$/, '');
    }

    function parseZoomPercent(rawValue) {
      if (typeof rawValue !== 'string') return null;
      const normalized = rawValue.replace(/%/g, '').replace(/\s+/g, '').replace(/,/g, '.');
      if (!normalized) return null;
      const parsed = Number.parseFloat(normalized);
      if (!Number.isFinite(parsed)) return null;
      return parsed / 100;
    }

    function applyZoomFromInput(rawValue) {
      const parsedFactor = parseZoomPercent(rawValue);
      if (parsedFactor == null) {
        updateZoomDisplay();
        return;
      }
      setZoomFactor(parsedFactor).catch((err) => console.error(err));
    }

    function updateZoomDisplay() {
      if (zoomDisplay) {
        zoomDisplay.value = formatZoomPercent(zoomFactor);
      }
      const canZoom = !!docType;
      zoomInBtn.disabled = !canZoom || zoomFactor >= (MAX_ZOOM - 0.01);
      zoomOutBtn.disabled = !canZoom || zoomFactor <= (MIN_ZOOM + 0.01);
      zoomFitBtn.disabled = !canZoom;
    }

    function setZoomControlsEnabled(enabled) {
      if (zoomDisplay) {
        zoomDisplay.disabled = !enabled;
      }
      if (!enabled) {
        zoomInBtn.disabled = true;
        zoomOutBtn.disabled = true;
        zoomFitBtn.disabled = true;
      } else {
        updateZoomDisplay();
      }
    }

    async function setZoomFactor(newFactor) {
      const clamped = clamp(newFactor, MIN_ZOOM, MAX_ZOOM);
      if (Math.abs(clamped - zoomFactor) < 0.001) {
        updateZoomDisplay();
        return;
      }
      zoomFactor = clamped;
      localStorage.setItem(ZOOM_KEY, zoomFactor.toFixed(2));
      updateZoomDisplay();
      if (!docType) return;
      await applyScale();
    }

    async function applyScale() {
      const newScale = fitScale * zoomFactor;
      const factor = newScale / scale;
      scale = newScale;
      if (Math.abs(factor - 1) > 0.001) {
        rescaleRects(factor);
      }
      for (const state of pageStates.values()) {
        state.drawing = false;
        state.previewRect = null;
      }
      await rerenderAllPages();
      if (activeMatchIndex >= 0) {
        focusMatch(activeMatchIndex, { behavior: 'instant' });
      } else {
        redrawAllOverlays();
      }
      syncViewerHeight();
    }

    function rescaleRects(factor) {
      for (const key of Object.keys(rectsByPage)) {
        const arr = rectsByPage[key];
        if (!Array.isArray(arr)) continue;
        rectsByPage[key] = arr.map((rect) => ({
          x: rect.x * factor,
          y: rect.y * factor,
          w: rect.w * factor,
          h: rect.h * factor,
        }));
      }
    }

    function applyRectToAllPages(rect, sourcePage) {
      if (docType !== 'pdf' || pageCount <= 1) return;
      for (let p = 1; p <= pageCount; p++) {
        if (p === sourcePage) continue;
        if (!rectsByPage[p]) rectsByPage[p] = [];
        rectsByPage[p].push({ ...rect });
        if (pageViews.has(p)) {
          drawOverlay(p);
        }
      }
    }

    async function rerenderAllPages() {
      if (!docType) return;
      for (let pageNum = 1; pageNum <= pageCount; pageNum++) {
        await renderPage(pageNum);
      }
    }

    function setActivePage(pageNumber) {
      if (!pageViews.has(pageNumber)) return;
      activePage = pageNumber;
      pageNumEl.textContent = pageNumber;
      for (const [num, view] of pageViews.entries()) {
        view.wrapper.classList.toggle('active', num === pageNumber);
      }
      updateClearButtonState();
    }

    function updateClearButtonState() {
      if (!docType) {
        btnClearRects.disabled = true;
        return;
      }
      const rects = rectsByPage[activePage] || [];
      btnClearRects.disabled = rects.length === 0;
    }

    function computeScaleForWidth(pageWidth) {
      const containerWidth = viewerContainer.clientWidth || viewerContainer.getBoundingClientRect().width;
      if (!containerWidth) return 1;
      const available = Math.max(containerWidth - 24, 200);
      const fitScale = available / pageWidth;
      if (!Number.isFinite(fitScale) || fitScale <= 0) return 1;
      return Math.min(1.3, fitScale);
    }

    function clamp(value, min, max) {
      return Math.min(max, Math.max(min, value));
    }

    window.addEventListener('resize', () => {
      syncViewerHeight();
      if (!docType || !basePageWidth) return;
      clearTimeout(resizeTimeout);
      resizeTimeout = setTimeout(async () => {
        const newFit = computeScaleForWidth(basePageWidth);
        if (!Number.isFinite(newFit) || newFit <= 0) return;
        const prevScale = scale;
        fitScale = newFit;
        const newScale = fitScale * zoomFactor;
        const factor = newScale / prevScale;
        scale = newScale;
        if (Math.abs(factor - 1) > 0.001) {
          rescaleRects(factor);
        }
        await rerenderAllPages();
        redrawAllOverlays();
        updateZoomDisplay();
        syncViewerHeight();
      }, 180);
    });

    function normalizeExtension(ext, defaultExt = '') {
      if (!ext) return defaultExt;
      return ext.startsWith('.') ? ext : `.${ext}`;
    }

    function sanitizeFileName(name) {
      if (!name || typeof name !== 'string') return getDefaultDocumentBase();
      const invalid = /[\\/:*?"<>|]+/g;
      const cleaned = name.replace(invalid, '_').trim();
      return cleaned || getDefaultDocumentBase();
    }

    function ensureExtension(name, ext) {
      const normalizedExt = normalizeExtension(ext, '');
      if (!normalizedExt) return name;
      if (/\.[^.]+$/.test(name)) {
        return name;
      }
      return `${name}${normalizedExt}`;
    }

    function forceExtension(name, ext) {
      const normalizedExt = normalizeExtension(ext, '');
      if (!normalizedExt) return name;
      const base = name.replace(/\.[^.]+$/, '');
      return `${base}${normalizedExt}`;
    }

    function buildAnonName(original, fallbackExt = '.pdf') {
      const normalizedExt = normalizeExtension(fallbackExt, '.pdf');
      if (namingStrategy === 'fixed') {
        return `anonim${normalizedExt}`;
      }
      const safeName = sanitizeFileName(original);
      const match = safeName.match(/(\.[^.]+)$/);
      const base = match ? safeName.slice(0, -match[0].length) : safeName;
      const ext = normalizedExt || (match ? match[0] : '');
      return `${base}_anonim${ext}`;
    }

    function t(key, vars = {}, localeOverride) {
      const locale = normalizeLocale(localeOverride) || currentLocale || FALLBACK_LOCALE;
      const dict = TRANSLATIONS[locale] || TRANSLATIONS[FALLBACK_LOCALE] || {};
      const fallbackDict = TRANSLATIONS[FALLBACK_LOCALE] || {};
      let template = dict[key];
      if (template === undefined) {
        template = fallbackDict[key];
      }
      if (template === undefined) {
        return '';
      }
      const text = String(template);
      return text.replace(/\{(\w+)\}/g, (_, name) => (name in vars ? String(vars[name]) : ''));
    }

    function normalizeLocale(locale) {
      if (!locale) return null;
      const lower = String(locale).toLowerCase();
      if (SUPPORTED_LOCALES.includes(lower)) return lower;
      const base = lower.split('-')[0];
      return SUPPORTED_LOCALES.includes(base) ? base : null;
    }

    function detectInitialLocale() {
      try {
        const stored = normalizeLocale(localStorage.getItem(LANG_STORAGE_KEY));
        if (stored) return stored;
      } catch (err) {
        // storage might be unavailable
      }
      const fromNavigator = Array.isArray(navigator.languages)
        ? navigator.languages.map(normalizeLocale).find(Boolean)
        : normalizeLocale(navigator.language);
      return fromNavigator || FALLBACK_LOCALE;
    }

    function applyTranslations(root = document) {
      const elements = root.querySelectorAll('*');
      for (const el of elements) {
        const dataset = el.dataset;
        if (!dataset) continue;
        const needsTranslation = Object.keys(dataset).some((key) => key.startsWith('i18n'));
        if (needsTranslation) {
          translateElement(el);
        }
      }
    }

    function translateElement(el) {
      if (!el || !el.dataset) return;
      const { dataset } = el;
      if (dataset.i18n) {
        const value = t(dataset.i18n);
        if (dataset.i18nType === 'html') {
          el.innerHTML = value;
        } else {
          el.textContent = value;
        }
      }
      for (const [dataKey, valueKey] of Object.entries(dataset)) {
        if (!dataKey.startsWith('i18nAttr')) continue;
        const rawName = dataKey.slice('i18nAttr'.length);
        if (!rawName) continue;
        const attrName = toAttrName(rawName);
        if (!attrName) continue;
        el.setAttribute(attrName, t(valueKey));
      }
    }

    function toAttrName(rawName) {
      if (!rawName) return '';
      return rawName.replace(/([A-Z])/g, (match, _grp, offset) => (offset ? '-' : '') + match.toLowerCase());
    }

    function formatNumber(value) {
      const code = LOCALE_INTL[currentLocale] || LOCALE_INTL[FALLBACK_LOCALE] || 'en';
      return new Intl.NumberFormat(code).format(value);
    }

    function refreshExportModeLabels() {
      if (!exportModeEl) return;
      const options = Array.from(exportModeEl.options);
      for (const option of options) {
        const key = option.dataset.i18nKey;
        if (key) {
          option.textContent = t(key);
        }
      }
    }

    function applyLocale(locale, { skipPersist = false, initial = false } = {}) {
      const normalized = normalizeLocale(locale) || FALLBACK_LOCALE;
      if (!skipPersist) {
        try {
          localStorage.setItem(LANG_STORAGE_KEY, normalized);
        } catch (err) {
          // storage might be unavailable; ignore
        }
      }
      currentLocale = normalized;
      document.documentElement.lang = normalized;
      document.title = t('app.windowTitle');
      if (languageSelect && languageSelect.value !== normalized) {
        languageSelect.value = normalized;
      }
      applyTranslations();
      refreshExportModeLabels();
      updateExportButtonLabel();
      updateExportNotice();
      setControlsHidden(document.body.classList.contains('controlsHidden'));
      if (!docType && !fileDrop.classList.contains('hasFile')) {
        setFileDropStatus(getDefaultDropText(), false);
      }
      updateSearchStatus();
    }

    function getDefaultDropText() {
      return t('drop.default');
    }

    function getDefaultDocumentBase() {
      const base = t('defaults.document');
      return base || 'documento';
    }

    function getDefaultDocumentName(ext = '.pdf') {
      return ensureExtension(getDefaultDocumentBase(), ext);
    }

    function guessImageExtension(file) {
      const type = (file && file.type ? file.type : '').toLowerCase();
      if (type) {
        if (type === 'image/jpeg') return '.jpg';
        if (type.startsWith('image/')) {
          const subtype = type.slice(6);
          const clean = subtype.includes('+') ? subtype.split('+')[0] : subtype;
          return normalizeExtension(clean);
        }
      }
      const name = (file && file.name ? file.name : '').toLowerCase();
      const match = name.match(/(\.[a-z0-9]{2,5})$/);
      if (match) return match[1];
      return '.png';
    }

    function loadImageElement(url) {
      return new Promise((resolve, reject) => {
        const img = new Image();
        img.onload = () => resolve(img);
        img.onerror = (err) => reject(err);
        img.src = url;
      });
    }

    function getMousePos(e, el) {
      const rect = el.getBoundingClientRect();
      const x = (e.clientX - rect.left) * (el.width / rect.width);
      const y = (e.clientY - rect.top) * (el.height / rect.height);
      return { x, y };
    }

    function isPointInsideRect(px, py, rect) {
      return px >= rect.x && px <= rect.x + rect.w && py >= rect.y && py <= rect.y + rect.h;
    }

    function normalizeRect(x1, y1, x2, y2) {
      const x = Math.min(x1, x2);
      const y = Math.min(y1, y2);
      const w = Math.abs(x2 - x1);
      const h = Math.abs(y2 - y1);
      return { x, y, w, h };
    }

  });
</script>
</body>
</html>
